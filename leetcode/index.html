<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Coding - Auckland New Zealand</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="No. Question Flag     (1). binary-search      1.1 二分查找 ❎     1.2 在排序数组中查找元素的第一个和最后一个位置 ❎   (2). DFS      2.1 字符串解码 [a]2[bc]      s = “3[a]2[bc]”    (3). Digit      3.1 回文数      模拟 123321 -&amp;gt; 233">
<meta property="og:type" content="website">
<meta property="og:title" content="Coding">
<meta property="og:url" content="http:&#x2F;&#x2F;iequa.com&#x2F;leetcode&#x2F;index.html">
<meta property="og:site_name" content="Auckland New Zealand">
<meta property="og:description" content="No. Question Flag     (1). binary-search      1.1 二分查找 ❎     1.2 在排序数组中查找元素的第一个和最后一个位置 ❎   (2). DFS      2.1 字符串解码 [a]2[bc]      s = “3[a]2[bc]”    (3). Digit      3.1 回文数      模拟 123321 -&amp;gt; 233">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-10-28T02:14:14.570Z">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon-Tiktok.ico">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <!-- blair add baidu tongji start... @2017.10.03 -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8864dc75a81a27b7e44c00138af95d66";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- blair add baidu tongji end ! @2017.10.03 -->

<!-- jiangting add start... @2020.08.30 -->
<!-- <div id="menu" class="duration-main" style="background-color: #e7e7e7"> -->
<!--   <p class="links-p" href="/">Blair</p> -->
<!--   <address class="icons"> -->
<!--     <a href="https://github.com/blair101" class="icon-font icon linkedin" target="_blank"></a> -->
<!--     <a href="https://cn.linkedin.com/pub/tianyu-dai/a8/818/44a" class="icon-font icon linkedin" target="_blank"></a> -->
<!--   </address> -->
<!--   <div class="hr1"></div> -->
<!--   <nav> -->
<!--     <div> -->
<!--     <a class="home" href="/">Home</a></div> -->
<!--     <p class="links-p" href="/">Home</p> -->
<!--     <nav class="tag-ath"> -->
<!--       <a class="proj" href="/categories">Category</a> -->
<!--       <a class="authors" href="/about">About</a> -->
<!--     </nav> -->
<!--   </nav> -->
<!--   <div class="hr2"></div> -->
<!--     <p class="links-p">Links</p> -->
<!--       <address class="links"> -->
<!--       <a class="proj" href="/article/Create-MyWorld">Projects</a> -->
<!--       <a class="friend">Friends</a></address><div class="hr3"> -->
<!--   </div> -->
<!--   <p class="end"></p> -->
<!--   <div id="menu-links" class="duration-main" style="top: -400px; background-color: #f5f5f5"> -->
<!--     <address> -->
<!--       <li><a target="_blank" href="http://lm7.xxxxxxxx.jp">Lm7</a></li> -->
<!--       <li><a target="_blank" href="http://www.pixiv.net/member.php?id=4933015">Domik</a></li> -->
<!--       <li><a target="_blank" href="http://hana-ui.moe">hana-ui</a></li> -->
<!--       <li><a target="_blank" href="http://fil.dtysky.moe">F-I-L</a></li> -->
<!--       <li><a target="_blank" href="http://paradise.dtysky.moe">Paradise</a></li> -->
<!--       <li><a target="_blank" href="http://moe-notes.dtysky.moe">MoeNotes</a></li> -->
<!--       <li><a target="_blank" href="http://kanata.dtysky.moe">Kanata</a></li> -->
<!--       <li><a target="_blank" href="http://blog.nekohand.moe">Nekohand</a></li> -->
<!--       <li><a target="_blank" href="http://www.jerryfu.net">JerryFu</a></li> -->
<!--       <li><a target="_blank" href="http://kawabangga.com">南史</a></li> -->
<!--       <li><a>Hide Links</a></li> -->
<!--       <li><a></a></li> -->
<!--     </address> -->
<!--   </div> -->
<!-- </div> -->
<!-- jiangting add end !  @2020.08.30 -->

<header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;" target="_blank" rel="noopener"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/leetcode">LC</a>
        
          <a class="main-nav-link" href="/ai1">AI</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://iequa.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <br>
    <section id="main" class="outer"><article id="page-" class="article article-type-page" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Coding
      <small class=article-detail-date-index>&nbsp; 2020-10-28</small>
    </h1>
  


        <div class=page-title></div>
        <br>
      </header>
    
    <div class="article-meta">
      <!--<a href="/leetcode/index.html" class="article-date">
  <time datetime="2020-10-28T02:14:14.570Z" itemprop="datePublished">2020-10-28</time>
</a>-->
      <!-- 
--><!-- by blair 160724 -->
      <!-- by blair
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/leetcode/index.html#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <!--# [Sea](https://leetcode-cn.com/company/shopee/)-->
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th>Question</th>
<th style="text-align:center">Flag</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(1).</td>
<td><strong>binary-search</strong></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">1.1 二分查找</a></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">1.2 在排序数组中查找元素的第一个和最后一个位置</a></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">(2).</td>
<td>DFS</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">2.1 字符串解码 [a]2[bc]</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td>s = “3[a]2[bc]”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">(3).</td>
<td>Digit</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">3.1 回文数</a>      模拟 123321 -&gt; 2332 -&gt; 33</td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">(4).</td>
<td>DP</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td><a href="https://leetcode-cn.com/problems/paint-fence/" target="_blank" rel="noopener">4.1 栅栏涂色</a>    <code>dp[i] = dp[i-2]*(k-1) + dp[i-1]*(k-1)</code></td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">4.2 区域和检索</a></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">4.3 Coin Change [零钱兑换]</a>      <code>dp[x] = min(dp[x], dp[x - coin] + 1)</code> <br><br> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mrow><mi>j</mi><mo>=</mo><mn>0</mn><mo>…</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mi mathvariant="normal">−</mi><mi>c</mi><mi mathvariant="normal">_</mi><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(i)= min\_{j=0…n−1} F(i−c\_j)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord mathdefault">c</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> <code>dp = [float('inf')] * (amount + 1)</code></td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">4.4 除自身以外数组的乘积</a></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">(5).</td>
<td>hash</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"> </td>
<td><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">5.1 两数之和</a></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">(6).</td>
<td>linkedList</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">6.1 相交链表</a> <code>romantic</code></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">6.2 环形链表</a> <code>hash</code></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">6.3 两数相加</a> <code>LinkNode 模拟</code></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">6.4 复制带随机指针的链表</a> ✔️</td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/company/shopee/" target="_blank" rel="noopener">6.5 LRUCache</a> class DLinkedNode</td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">6.6 删除链表的倒数第N个节点</a></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">6.7 排序链表</a></td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center">(7).</td>
<td>stack</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">7.1 有效的括号</a> <code>if i == ')' and len(stack)&gt; 0 and stack[-1] == '(': stack.pop()</code></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">(8).</td>
<td>string</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">8.1 字符串相加</a> 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和</td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">8.2 比较版本号</a></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><s><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">8.3 字符串解码</a></s></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">8.4 无重复字符的最长子串</a> sliding window</td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/next-greater-element-iii/" target="_blank" rel="noopener">8.5 下一个更大元素 III</a> ， 模拟复杂 <a href="https://leetcode-cn.com/problems/next-greater-element-iii/solution/xia-yi-ge-geng-da-yuan-su-iii-by-leetcode/" target="_blank" rel="noopener">见题解</a></td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">8.6 全排列</a></td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">(9).</td>
<td>tree</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">9.1 从前序与中序遍历序列构造二叉树</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">9.2 二叉树的中序遍历</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">9.3 二叉树的右视图</a></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 5 8 4 7 6 5 3 1</span><br><span class="line">#</span><br><span class="line"># 1 5 8 5 7 6 4 3 1</span><br><span class="line">#</span><br><span class="line"># 1 5 8 5 1 3 4 6 7</span><br></pre></td></tr></table></figure>
<hr />
<p>very good good:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, next=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"><span class="comment"># 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 输入: 4-&gt;2-&gt;1-&gt;3</span></span><br><span class="line"><span class="comment"># 输出: 1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head <span class="comment"># termination.</span></span><br><span class="line">        <span class="comment"># cut the LinkedList at the mid index.</span></span><br><span class="line">        slow, fast = head, head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast, slow = fast.next.next, slow.next</span><br><span class="line">        mid, slow.next = slow.next, <span class="literal">None</span> <span class="comment"># save and cut.</span></span><br><span class="line">        <span class="comment"># recursive for cutting.</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(mid)</span><br><span class="line">        <span class="comment"># merge `left` and `right` linked list and return it.</span></span><br><span class="line">        h = res = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val: h.next, left = left, left.next</span><br><span class="line">            <span class="keyword">else</span>: h.next, right = right, right.next</span><br><span class="line">            h = h.next</span><br><span class="line">        h.next = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure>
<p>字符串相加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line"></span><br><span class="line">        num1 = <span class="string">""</span>.join(list(reversed(num1)))</span><br><span class="line">        num2 = <span class="string">""</span>.join(list(reversed(num2)))</span><br><span class="line"></span><br><span class="line">        diff2 = len(num1) - len(num2)</span><br><span class="line"></span><br><span class="line">        diff1 = diff2 * <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        num1 = num1 + (<span class="string">"0"</span> * diff1)</span><br><span class="line">        num2 = num2 + (<span class="string">"0"</span> * diff2)</span><br><span class="line"></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num1)):</span><br><span class="line">            d1 = int(num1[i])</span><br><span class="line">            d2 = int(num2[i])</span><br><span class="line"></span><br><span class="line">            tmp = carry + d1 + d2</span><br><span class="line">            res += str(tmp % <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            carry = tmp // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">            res += str(carry % <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(list(reversed(res)))</span><br></pre></td></tr></table></figure>
<p>无重复字符的最长子串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = set()</span><br><span class="line">        n = len(s)</span><br><span class="line"></span><br><span class="line">        r = <span class="number">-1</span> <span class="comment"># rk init -1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> l != <span class="number">0</span>:</span><br><span class="line">                occ.remove(s[l<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> r+<span class="number">1</span> &lt; n <span class="keyword">and</span> s[r+<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                occ.add(s[r+<span class="number">1</span>])</span><br><span class="line">                r += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="剑指"><a class="markdownIt-Anchor" href="#剑指"></a> <a href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener">剑指</a></h1>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th>Question</th>
<th>Flag</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>easy</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td>二叉树的镜像： <code>swap后+递归</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td>从尾到头打印链表： <br><code>reversePrint(head.next) + [head.val]</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td>反转链表    [<strong>Recursion</strong>] (需要在写一个循环版) <br><code>cur = self.reverseList(head.next)</code><br><code>head.head.next = head</code><br><code>head.next = None</code><br><code>return cur</code></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td>二叉搜索树的第k大节点    [中序遍历 倒序] <br><code>dfs(root.right)</code><br> <code>self.k -= 1</code> <br> <code>dfs(root.left)</code></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td>合并两个排序的链表    [<strong>Recursion</strong>] <br> p.next = self.mergeTwoLists(l1.next, l2)</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td>二叉树的最近公共祖先    [<strong>Recursion</strong>]</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td>和为s的连续正数序列    [sliding window] <br><br> input：target = 9 <br> output：[[2,3,4],[4,5]]</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td>二叉搜索树的最近公共祖先    [<strong>Recursion</strong> + 剪枝]</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">圆圈中最后剩下的数字</a> <code>需要在review..</code></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td>平衡二叉树 <br> abs(maxHigh(root.left) - maxHigh(root.right)) &lt;= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td>对称的二叉树</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td>包含min函数的栈</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td><a href="http://localhost:5000/leetcode/#32-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0" target="_blank" rel="noopener">最小的k个数 【heapq 堆排序 的逆向思维】</a></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td>n个骰子的点数</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">35</td>
<td>顺时针打印矩阵</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">36</td>
<td>滑动窗口的最大值</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">37</td>
<td>0～n-1中缺失的数字</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><strong>medium</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">42</td>
<td>求1+2+…+n</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">43</td>
<td>数组中数字出现的次数</td>
<td>so hard</td>
</tr>
<tr>
<td style="text-align:center">44</td>
<td>复杂链表的复制</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">45</td>
<td>数组中数字出现的次数</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">46</td>
<td>重建二叉树</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">47</td>
<td>礼物的最大价值 <code>f = [len(grid[0]) * [0]] * len(grid)</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td>从上到下打印二叉树 III <code>queue.append([root, 0])</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">49</td>
<td>丑数 n2, n3, n5 = dp[a] * 2, dp[b] * 3, dp[c] * 5</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">50</td>
<td>二叉搜索树与双向链表 <code>self.pre = None, self.head = cur; self.pre = cur</code></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">51</td>
<td>股票的最大利润 （买卖一次）  <br><code>cost, profit = float(&quot;+inf&quot;), 0</code> <br> for price in prices:<br>    <code>cost, profit = min(cost, price), max(profit, price - cost)</code></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">54</td>
<td>构建乘积数组</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">55</td>
<td><strong>二叉树中和为某一值的路径</strong> <br><br> <code>if sum == 0 and root.left is None and root.right is None</code></td>
<td><br><br> ✔️</td>
</tr>
<tr>
<td style="text-align:center">56</td>
<td>把数组排成最小的数 <code>strs.sort(key=cmp_to_key(sort_rule))</code></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">57</td>
<td>剪绳子 (1) n &lt; 4 (2) n == 4 (3) n &gt; 4, 多个 == 3 段</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">58</td>
<td>字符串的排列 <code>c = list(s) res = [] def dfs(x):</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">59</td>
<td>把数字翻译成字符串 <code>f[i] = f[i-1] + f[i-2]</code> 同 打家劫舍</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">60</td>
<td>二叉搜索树的后序遍历序列 <code>def recur(i, j):</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">61</td>
<td>机器人的运动范围 <code>bfs</code> good</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">62</td>
<td>队列的最大值</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">65</td>
<td>最长不含重复字符的子字符串 <code>滑动窗口</code></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">66</td>
<td>矩阵中的路径</td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">68</td>
<td>数值的整数次方  （1）当 n 为偶数 （2）当 n 为奇数</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">70</td>
<td>把字符串转换成整数 <code>int_max, int_min, bndry = 2 ** 31 - 1, -2 ** 31, 2 ** 31 // 10: res &gt; bndry or res == bndry and c &gt; '7'</code></td>
<td>✔️</td>
</tr>
<tr>
<td style="text-align:center">71</td>
<td>表示数值的字符串： <a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/" target="_blank" rel="noopener">确定有限状态自动机</a> <br> <a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/" target="_blank" rel="noopener">面试题20. 表示数值的字符串（有限状态自动机，清晰图解）</a></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><strong>hard</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">72</td>
<td>数据流中的中位数</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">73</td>
<td>序列化二叉树</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">64</td>
<td>1～n整数中1出现的次数</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">74</td>
<td>数组中的逆序对</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">75</td>
<td>正则表达式匹配</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th>Pass Question</th>
<th>Flag</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>pass_easy</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td>左旋转字符串</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>链表中倒数第k个节点</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>二叉树的深度</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td>打印从1到最大的n位数： <code>sum = 10 ** n</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td>替换空格</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td>二进制中1的个数 [n = n &amp; (n-1)]</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td>用两个栈实现队列</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td>从上到下打印二叉树II     <code>queue.append([root, 0])</code> 或 <code>for _ in range(queue_size)</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td>数组中出现次数超过一半的数字</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td>数组中重复的数字 set()</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td>和为s的两个数字  [sliding window]</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td>调整数组顺序使奇数位于偶数前面</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td>两个链表的第一个公共节点</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td>第一个只出现一次的字符:   Python 3.6 后，默认字典就是有序的，无需用 OrderedDict()</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td>连续子数组的最大和 <code>dp[i] = dp[i-1] + nums[i]</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td>删除链表的节点 pre, p</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td>不用加减乘除做加法  add(a ^ b, (a &amp; b) &lt;&lt; 1)</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td>在排序数组中查找数字I</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td>旋转数组的最小数字 <code>numbers[high]</code></td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">34</td>
<td>扑克牌中的顺子 ma - mi &lt; 5</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">38</td>
<td>翻转单词顺序</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">39</td>
<td>青蛙跳台阶问题</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td>二维数组中的查找</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">41</td>
<td>斐波那契数列</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center"><strong>pass_medium</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">52</td>
<td>栈的压入、弹出序列 (+stack 辅助)</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">53</td>
<td>剑指 Offer 32 - III. 从上到下打印二叉树 III</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">63</td>
<td>树的子结构</td>
<td>❎</td>
</tr>
<tr>
<td style="text-align:center">67</td>
<td>数字序列中某一位的数字 <code>找规律, pass</code></td>
<td><strong>NG</strong></td>
</tr>
<tr>
<td style="text-align:center">69</td>
<td>剪绳子II</td>
<td><strong>Not Good</strong>, so pass.</td>
</tr>
</tbody>
</table>
<h2 id="1-tree"><a class="markdownIt-Anchor" href="#1-tree"></a> 1. Tree</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">            dfs(cur.left) <span class="comment"># 递归左子树</span></span><br><span class="line">            <span class="keyword">if</span> self.pre: <span class="comment"># 修改节点引用</span></span><br><span class="line">                self.pre.right, cur.left = cur, self.pre</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 记录头节点</span></span><br><span class="line">                self.head = cur</span><br><span class="line">            self.pre = cur <span class="comment"># 保存 cur</span></span><br><span class="line">            dfs(cur.right) <span class="comment"># 递归右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        self.head.left, self.pre.right = self.pre, self.head</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/" target="_blank" rel="noopener">题解链接</a></p>
<h3 id="11-构造二叉树"><a class="markdownIt-Anchor" href="#11-构造二叉树"></a> 1.1 构造二叉树</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creatTree</span><span class="params">(vals)</span>:</span></span><br><span class="line">    nodes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(vals)):</span><br><span class="line">        cur_val = vals[i]</span><br><span class="line">        <span class="keyword">if</span> cur_val <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            cur_node = Node(cur_val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur_node = <span class="literal">None</span></span><br><span class="line">        nodes.append(cur_node)</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 0, 1-1/2, 2-1/2</span></span><br><span class="line">            par_id = (i - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                nodes[par_id].left = cur_node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nodes[par_id].right = cur_node</span><br><span class="line">    <span class="keyword">return</span> nodes[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_out</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    print(root.val)</span><br><span class="line">    pre_out(root.left)</span><br><span class="line">    pre_out(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    vals = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line">    root = creatTree(vals)</span><br><span class="line">    pre_out(root)</span><br></pre></td></tr></table></figure>
<h3 id="12-平衡二叉树"><a class="markdownIt-Anchor" href="#12-平衡二叉树"></a> 1.2 平衡二叉树</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxHigh</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> max(maxHigh(root.left), maxHigh(root.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> abs(maxHigh(root.left) - maxHigh(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure>
<h3 id="13-二叉树的镜像"><a class="markdownIt-Anchor" href="#13-二叉树的镜像"></a> 1.3 二叉树的镜像</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        node = root.left</span><br><span class="line">        root.left = self.mirrorTree(root.right)</span><br><span class="line">        root.right = self.mirrorTree(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="14-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#14-二叉树的最近公共祖先"></a> 1.4 二叉树的最近公共祖先</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 当越过叶节点，则直接返回 null</span></span><br><span class="line">        <span class="comment"># 当 rootroot 等于 p, q， 则直接返回 root</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><strong>二叉搜索树的最近公共祖先</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 算法:</span></span><br><span class="line"><span class="comment"># 1. 从根节点开始遍历树</span></span><br><span class="line"><span class="comment"># 2. 如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 1 的操作</span></span><br><span class="line"><span class="comment"># 3. 如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 1 的操作</span></span><br><span class="line"><span class="comment"># 4. 如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 LCA 了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># Value of current node or parent node.</span></span><br><span class="line">        parent_val = root.val</span><br><span class="line">        <span class="comment"># Value of p</span></span><br><span class="line">        p_val = p.val</span><br><span class="line">        <span class="comment"># Value of q</span></span><br><span class="line">        q_val = q.val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If both p and q are greater than parent</span></span><br><span class="line">        <span class="keyword">if</span> p_val &gt; parent_val <span class="keyword">and</span> q_val &gt; parent_val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="comment"># If both p and q are lesser than parent</span></span><br><span class="line">        <span class="keyword">elif</span> p_val &lt; parent_val <span class="keyword">and</span> q_val &lt; parent_val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="comment"># We have found the split point, i.e. the LCA node.</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="15-对称的二叉树"><a class="markdownIt-Anchor" href="#15-对称的二叉树"></a> 1.5 对称的二叉树</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetricHelper</span><span class="params">(left: TreeNode, right: TreeNode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">or</span> right == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> isSymmetricHelper(left.left, right.right) <span class="keyword">and</span> isSymmetricHelper(left.right, right.left)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">None</span> <span class="keyword">or</span> isSymmetricHelper(root.left, root.right)</span><br></pre></td></tr></table></figure>
<h3 id="16-从上到下打印二叉树-ii-iii"><a class="markdownIt-Anchor" href="#16-从上到下打印二叉树-ii-iii"></a> 1.6 从上到下打印二叉树 II / III</h3>
<p>从上到下打印二叉树 II</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                queue.append(cur.left)</span><br><span class="line">                queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>从上到下打印二叉树 III</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append([root, <span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        tmp_dict = dict()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur, level = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> tmp_dict.get(level) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                tmp_dict[level].append(cur.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp_dict[level] = [cur.val]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append([cur.left, level + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append([cur.right, level + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ix <span class="keyword">in</span> range(len(tmp_dict)):</span><br><span class="line">            <span class="keyword">if</span> ix % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res.append(tmp_dict[ix][::<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(tmp_dict[ix])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="17-二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#17-二叉树中和为某一值的路径"></a> 1.7 二叉树中和为某一值的路径</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    self.path.append(root.val)</span><br><span class="line">    sum = sum - root.val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sum == <span class="number">0</span> <span class="keyword">and</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.res.append(list(self.path))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root.left:</span><br><span class="line">        self.pathSum(root.left, sum)</span><br><span class="line">    <span class="keyword">if</span> root.right:</span><br><span class="line">        self.pathSum(root.right, sum)</span><br><span class="line">    </span><br><span class="line">    self.path.pop()</span><br><span class="line">    <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
<h3 id="18-二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#18-二叉搜索树的后序遍历序列"></a> 1.8 二叉搜索树的后序遍历序列</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder: [int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            p = i</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> postorder[p] &lt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            m = p</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> postorder[p] &gt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> p == j <span class="keyword">and</span> recur(i, m - <span class="number">1</span>) <span class="keyword">and</span> recur(m, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="19-二叉搜索树与双向链表"><a class="markdownIt-Anchor" href="#19-二叉搜索树与双向链表"></a> 1.9 二叉搜索树与双向链表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">            dfs(cur.left) <span class="comment"># 递归左子树</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> self.pre: <span class="comment"># 修改节点引用</span></span><br><span class="line">                self.pre.right = cur</span><br><span class="line">                cur.left = self.pre</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 记录头节点</span></span><br><span class="line">                self.head = cur</span><br><span class="line">            self.pre = cur <span class="comment"># 保存 cur</span></span><br><span class="line">            </span><br><span class="line">            dfs(cur.right) <span class="comment"># 递归右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        self.head.left = self.pre</span><br><span class="line">        self.pre.right = self.head</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure>
<h2 id="2-linkedlist"><a class="markdownIt-Anchor" href="#2-linkedlist"></a> 2. LinkedList</h2>
<h3 id="21-从尾到头打印链表"><a class="markdownIt-Anchor" href="#21-从尾到头打印链表"></a> 2.1 从尾到头打印链表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.reversePrint(head.next) + [head.val]</span><br></pre></td></tr></table></figure>
<h3 id="22-反转链表"><a class="markdownIt-Anchor" href="#22-反转链表"></a> 2.2 反转链表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span></span><br><span class="line"><span class="comment"># 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step1: 1-&gt;2-&gt;3-&gt;4&lt;-5</span></span><br><span class="line"><span class="comment"># step2: 1-&gt;2-&gt;3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment"># step3: 1-&gt;2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># step4: NULL&lt;-1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        cur = self.reverseList(head.next)</span><br><span class="line">        <span class="comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">        <span class="comment"># 而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">        <span class="comment"># 所以head.next.next 就是5-&gt;4</span></span><br><span class="line">        head.head.next = head</span><br><span class="line">        <span class="comment"># 防止链表循环，需要将head.next设置为空</span></span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 每层**Recursion**函数都返回cur，也就是最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
<h3 id="23-复杂链表的复制"><a class="markdownIt-Anchor" href="#23-复杂链表的复制"></a> 2.3 复杂链表的复制</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Definition for a Node.</span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, x: int, next: &apos;Node&apos; = None, random: &apos;Node&apos; = None):</span><br><span class="line">        self.val = int(x)</span><br><span class="line">        self.next = next</span><br><span class="line">        self.random = random</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class Solution:</span><br><span class="line">    def copyRandomList(self, head: &apos;Node&apos;) -&gt; &apos;Node&apos;:</span><br></pre></td></tr></table></figure>
<h2 id="3-string"><a class="markdownIt-Anchor" href="#3-string"></a> 3. String</h2>
<p>字符串全排列 permutation</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：s = "abc"</span></span><br><span class="line"><span class="comment"># 输出：["abc","acb","bac","bca","cab","cba"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        c = list(s)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == len(c) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">''</span>.join(c))  <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dic = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span><br><span class="line">                <span class="comment"># if c[i] in dic: continue  # 重复，因此剪枝</span></span><br><span class="line">                <span class="comment"># dic.add(c[i])</span></span><br><span class="line">                c[i], c[x] = c[x], c[i]  <span class="comment"># 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>)               <span class="comment"># 开启固定第 x + 1 位字符</span></span><br><span class="line">                c[i], c[x] = c[x], c[i]  <span class="comment"># 恢复交换</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="4-array-sort"><a class="markdownIt-Anchor" href="#4-array-sort"></a> 4. Array &amp; Sort</h2>
<h3 id="41-圆圈中最后剩下的数字"><a class="markdownIt-Anchor" href="#41-圆圈中最后剩下的数字"></a> 4.1 圆圈中最后剩下的数字</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入: n = 5, m = 3</span></span><br><span class="line"><span class="comment"># 输出: 3</span></span><br><span class="line"><span class="comment"># 0, 1, 2, 3, 4</span></span><br><span class="line"><span class="comment"># 题目中的要求可以表述为：给定一个长度为 n 的序列，每次向后数 m 个元素并删除，那么最终留下的是第几个元素？</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 这个问题很难快速给出答案。但是同时也要看到，这个问题似乎有拆分为较小子问题的潜质：如果我们知道对于一个长度 n - 1 的序列，留下的是第几个元素，那么我们就可以由此计算出长度为 n 的序列的答案。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 算法</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 我们将上述问题建模为函数 f(n, m)，该函数的返回值为最终留下的元素的序号。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 首先，长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有 f(n, m) = (m % n + x) % n = (m + x) % n。</span></span><br><span class="line"><span class="comment"># Python 默认的递归深度不够，需要手动设置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python解释器默认对递归深度设定为998，但可以用sys.setrecursionlimit(99999999)来打破这个限制。</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    x = f(n - <span class="number">1</span>, m)</span><br><span class="line">    <span class="keyword">return</span> (m % n + x) % n</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return (m + x) % n</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> f(n, m)</span><br></pre></td></tr></table></figure>
<h3 id="42-最小的k个数"><a class="markdownIt-Anchor" href="#42-最小的k个数"></a> 4.2 最小的k个数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line"></span><br><span class="line">        hp = [-x <span class="keyword">for</span> x <span class="keyword">in</span> arr[:k]]</span><br><span class="line"></span><br><span class="line">        heapq.heapify(hp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(arr)):</span><br><span class="line">            <span class="keyword">if</span> -hp[<span class="number">0</span>] &gt; arr[i]:</span><br><span class="line">                heapq.heappop(hp)</span><br><span class="line">                heapq.heappush(hp, -arr[i])</span><br><span class="line"></span><br><span class="line">        ans = [-x <span class="keyword">for</span> x <span class="keyword">in</span> hp]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="43-n个骰子的点数"><a class="markdownIt-Anchor" href="#43-n个骰子的点数"></a> 4.3 n个骰子的点数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</span><br><span class="line">#</span><br><span class="line"># 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</span><br><span class="line">#</span><br><span class="line"># 输入: 1</span><br><span class="line"># 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line">#</span><br><span class="line"># 输入: 2</span><br><span class="line"># 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 通过题目我们知道一共投掷 n 枚骰子，那最后一个阶段很显然就是：当投掷完 n 枚骰子后，各个点数出现的次数。</span><br><span class="line">#</span><br><span class="line"># 注意，这里的点数指的是前 n 枚骰子的点数和，而不是第 n 枚骰子的点数，下文同理。</span><br><span class="line">#</span><br><span class="line"># 找出了最后一个阶段，那状态表示就简单了。</span><br><span class="line">#</span><br><span class="line"># 首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子。</span><br><span class="line"># 然后用第二维来表示投掷完这些骰子后，可能出现的点数。</span><br><span class="line"># 数组的值就表示，该阶段各个点数出现的次数。</span><br><span class="line"># 所以状态表示就是这样的：dp[i][j] ，表示投掷完 i 枚骰子后，点数 j 的出现次数。</span><br><span class="line"></span><br><span class="line"># dp[i][j] += dp[i-1][j-cur];</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, n: int)</span> -&gt; List[float]:</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * (<span class="number">6</span> * n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">11</span> + <span class="number">1</span>)]  <span class="comment"># 索引0不取，后面取到最大索引6*n</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):  <span class="comment"># init</span></span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):  <span class="comment"># 从第二轮抛掷开始算</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">6</span> * i + <span class="number">1</span>):  <span class="comment"># 第二轮抛掷最小和为2，从大到小更新对应的抛掷次数</span></span><br><span class="line">                <span class="comment"># dp[j] = 0  # 每次投掷要从0更新dp[j]大小，点数和出现的次数要重新计算</span></span><br><span class="line">                <span class="keyword">for</span> cur <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):  <span class="comment"># 每次抛掷的点数</span></span><br><span class="line">                    <span class="keyword">if</span> j - cur &lt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> j - cur &gt; (i - <span class="number">1</span>) * <span class="number">6</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - cur]  <span class="comment"># 根据上一轮来更新当前轮数据</span></span><br><span class="line">                    print(<span class="string">f'<span class="subst">&#123;i&#125;</span>, <span class="subst">&#123;j&#125;</span>, ==== <span class="subst">&#123;i<span class="number">-1</span>&#125;</span> <span class="subst">&#123;j-cur&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">        sum_ = <span class="number">6</span> ** n</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">6</span> * n + <span class="number">1</span>):</span><br><span class="line">            res.append(dp[n][i] * <span class="number">1.0</span> / sum_)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="44-顺时针打印矩阵"><a class="markdownIt-Anchor" href="#44-顺时针打印矩阵"></a> 4.4 顺时针打印矩阵</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    @file: e.spiralOrder.py</span></span><br><span class="line"><span class="string">    @date: 2020-09-07 4:19 PM</span></span><br><span class="line"><span class="string">    @desc: 剑指 Offer 29. 顺时针打印矩阵</span></span><br><span class="line"><span class="string">    @url : https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：matrix = [</span></span><br><span class="line"><span class="comment">#     [1,2,3,4],</span></span><br><span class="line"><span class="comment">#     [5,6,7,8],</span></span><br><span class="line"><span class="comment">#     [9,10,11,12]</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"><span class="comment"># 输出：[</span></span><br><span class="line"><span class="comment">#     1,2,3,4,</span></span><br><span class="line"><span class="comment">#     8,12,11,10,</span></span><br><span class="line"><span class="comment">#     9,5,6,7</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line"></span><br><span class="line">        rows, columns = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        order = list()</span><br><span class="line">        left, right, top, bottom = <span class="number">0</span>, columns - <span class="number">1</span>, <span class="number">0</span>, rows - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> top &lt;= bottom:</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">                order.append(matrix[top][column])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> range(top + <span class="number">1</span>, bottom + <span class="number">1</span>):</span><br><span class="line">                order.append(matrix[row][right])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt; right <span class="keyword">and</span> top &lt; bottom:</span><br><span class="line">                <span class="keyword">for</span> column <span class="keyword">in</span> range(right - <span class="number">1</span>, left, <span class="number">-1</span>):</span><br><span class="line">                    order.append(matrix[bottom][column])</span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> range(bottom, top, <span class="number">-1</span>):</span><br><span class="line">                    order.append(matrix[row][left])</span><br><span class="line"></span><br><span class="line">            left, right, top, bottom = left + <span class="number">1</span>, right - <span class="number">1</span>, top + <span class="number">1</span>, bottom - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> order</span><br></pre></td></tr></table></figure>
<h3 id="45-把数组排成最小的数"><a class="markdownIt-Anchor" href="#45-把数组排成最小的数"></a> 4.5 把数组排成最小的数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sort_rule</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            a, b = x + y, y + x</span><br><span class="line">            <span class="keyword">if</span> a &gt; b:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> a &lt; b:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        strs = [str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">        strs.sort(key=cmp_to_key(sort_rule))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(strs)</span><br></pre></td></tr></table></figure>
<h3 id="46-把字符串转换成整数"><a class="markdownIt-Anchor" href="#46-把字符串转换成整数"></a> 4.6 把字符串转换成整数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        str = str.strip()                      <span class="comment"># 删除首尾空格</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str: <span class="keyword">return</span> <span class="number">0</span>                   <span class="comment"># 字符串为空则直接返回</span></span><br><span class="line">        res, i, sign = <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        int_max, int_min, bndry = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, <span class="number">-2</span> ** <span class="number">31</span>, <span class="number">2</span> ** <span class="number">31</span> // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">'-'</span>: sign = <span class="number">-1</span>            <span class="comment"># 保存负号</span></span><br><span class="line">        <span class="keyword">elif</span> str[<span class="number">0</span>] != <span class="string">'+'</span>: i = <span class="number">0</span>              <span class="comment"># 若无符号位，则需从 i = 0 开始数字拼接</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str[i:]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">'0'</span> &lt;= c &lt;= <span class="string">'9'</span> : <span class="keyword">break</span>     <span class="comment"># 遇到非数字的字符则跳出</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; bndry <span class="keyword">or</span> res == bndry <span class="keyword">and</span> c &gt; <span class="string">'7'</span>: <span class="keyword">return</span> int_max <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> int_min <span class="comment"># 数字越界处理</span></span><br><span class="line">            res = <span class="number">10</span> * res + int(c) <span class="comment"># 数字拼接</span></span><br><span class="line">        <span class="keyword">return</span> sign * res</span><br></pre></td></tr></table></figure>
<h3 id="47-数值的整数次方-递归2分"><a class="markdownIt-Anchor" href="#47-数值的整数次方-递归2分"></a> 4.7 数值的整数次方 (递归+2分)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: x, n = <span class="number">1</span> / x, -n</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>: res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="5-sliding-window"><a class="markdownIt-Anchor" href="#5-sliding-window"></a> 5. sliding window</h2>
<p>剑指 Offer 59 - I. 滑动窗口的最大值 - (同理于包含 min 函数的栈)</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/" target="_blank" rel="noopener">answ</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span></span><br><span class="line"><span class="comment"># 输出: [3,3,5,5,6,7]</span></span><br><span class="line"><span class="comment"># 解释:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   滑动窗口的位置                最大值</span></span><br><span class="line"><span class="comment"># ---------------               -----</span></span><br><span class="line"><span class="comment"># [1  3  -1] -3  5  3  6  7       3</span></span><br><span class="line"><span class="comment">#  1 [3  -1  -3] 5  3  6  7       3</span></span><br><span class="line"><span class="comment">#  1  3 [-1  -3  5] 3  6  7       5</span></span><br><span class="line"><span class="comment">#  1  3  -1 [-3  5  3] 6  7       5</span></span><br><span class="line"><span class="comment">#  1  3  -1  -3 [5  3  6] 7       6</span></span><br><span class="line"><span class="comment">#  1  3  -1  -3  5 [3  6  7]      7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k): <span class="comment"># 未形成窗口</span></span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">        res = [deque[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums)): <span class="comment"># 形成窗口后</span></span><br><span class="line">            <span class="comment">#[0~k-1], [1~k], [2~k+1]</span></span><br><span class="line">            <span class="keyword">if</span> deque[<span class="number">0</span>] == nums[i - k]:</span><br><span class="line">                deque.popleft()</span><br><span class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> deque[<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                deque.pop()</span><br><span class="line">            deque.append(nums[i])</span><br><span class="line">            res.append(deque[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ul>
<li><a href="https://blog.csdn.net/qq_24243877" target="_blank" rel="noopener">成长之路 0607offer</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35707293" target="_blank" rel="noopener">知乎： [Leetcode][动态规划]相关题目汇总/分析/总结</a></li>
<li><a href="https://www.jianshu.com/p/af880bbba792" target="_blank" rel="noopener">简书： 2019 算法面试相关(leetcode)–动态规划(Dynamic Programming)</a></li>
<li><a href="https://blog.csdn.net/EbowTang/article/details/50791500" target="_blank" rel="noopener">CSDN leetcode DP</a></li>
<li><a href="https://blog.csdn.net/fuxuemingzhu/article/details/105183554" target="_blank" rel="noopener">刷完700多题后的首次总结：LeetCode应该怎么刷？</a></li>
<li><a href="https://www.cnblogs.com/kubidemanong/p/10996134.html" target="_blank" rel="noopener">小白一路走来，连续刷题三年，谈谈我的算法学习经验</a><br />
<a href="https://codebunk.com/b/3421100160572/" target="_blank" rel="noopener">codebunk.com</a><br />
<a href="https://www.dattyrabbit.cn/articles/2020/08/16/1597576674555.html?utm_source=ld246.com" target="_blank" rel="noopener">《程序员的算法趣题》-开坑记录</a></li>
</ul>

      
    
    </div>
    
      <div class="article-toc">
        <h3>Contents</h3>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#剑指"><span class="toc-text"> 剑指</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-tree"><span class="toc-text"> 1. Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-构造二叉树"><span class="toc-text"> 1.1 构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-平衡二叉树"><span class="toc-text"> 1.2 平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-二叉树的镜像"><span class="toc-text"> 1.3 二叉树的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-二叉树的最近公共祖先"><span class="toc-text"> 1.4 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-对称的二叉树"><span class="toc-text"> 1.5 对称的二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-从上到下打印二叉树-ii-iii"><span class="toc-text"> 1.6 从上到下打印二叉树 II / III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-二叉树中和为某一值的路径"><span class="toc-text"> 1.7 二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-二叉搜索树的后序遍历序列"><span class="toc-text"> 1.8 二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-二叉搜索树与双向链表"><span class="toc-text"> 1.9 二叉搜索树与双向链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-linkedlist"><span class="toc-text"> 2. LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-从尾到头打印链表"><span class="toc-text"> 2.1 从尾到头打印链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-反转链表"><span class="toc-text"> 2.2 反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-复杂链表的复制"><span class="toc-text"> 2.3 复杂链表的复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-string"><span class="toc-text"> 3. String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-array-sort"><span class="toc-text"> 4. Array &amp; Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-圆圈中最后剩下的数字"><span class="toc-text"> 4.1 圆圈中最后剩下的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-最小的k个数"><span class="toc-text"> 4.2 最小的k个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-n个骰子的点数"><span class="toc-text"> 4.3 n个骰子的点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-顺时针打印矩阵"><span class="toc-text"> 4.4 顺时针打印矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-把数组排成最小的数"><span class="toc-text"> 4.5 把数组排成最小的数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-把字符串转换成整数"><span class="toc-text"> 4.6 把字符串转换成整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-数值的整数次方-递归2分"><span class="toc-text"> 4.7 数值的整数次方 (递归+2分)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-sliding-window"><span class="toc-text"> 5. sliding window</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-text"> Reference</span></a></li></ol></li></ol>
      </div>
    
    
      <footer class="article-footer">
        <!-- <div class="well" style="width:100px; height:30px;"></div>  by blair-->
        
 <!-- by blair add 160724-->
        <!--
        <div style="width:100px; height:30px;"></div> by blair add 160724
        -->
        

      </footer>
    
  </div>
  
    
  
</article>

<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Blair Chan&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/52binge/hexo-theme-blairos" target="_blank" rel="noopener">blairos</a>
    </div>
  </div>
</footer>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML,http://myserver.com/MathJax/config/local/local.js">
</script>

    
<script type="text/javascript"> <!-- add by blair 0724 type=text/javascript -->
  var disqus_shortname = 'blairos-sn';
  
  var disqus_url = 'http://iequa.com/leetcode/index.html';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
