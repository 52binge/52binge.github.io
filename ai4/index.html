<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Auckland New Zealand</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Auckland New Zealand">
<meta property="og:url" content="http://shopee.ai/ai4/index.html">
<meta property="og:site_name" content="Auckland New Zealand">
<meta property="og:description">
<meta property="og:image" content="http://shopee.ai/images/icpc/BinaryTree-1.png">
<meta property="og:updated_time" content="2019-07-02T06:32:44.863Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Auckland New Zealand">
<meta name="twitter:description">
<meta name="twitter:image" content="http://shopee.ai/images/icpc/BinaryTree-1.png">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <!-- blair add baidu tongji start... @2017.10.03 -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8864dc75a81a27b7e44c00138af95d66";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- blair add baidu tongji end ! @2017.10.03 -->

<header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/ai1">AI</a>
        
          <a class="main-nav-link" href="/english">English</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shopee.ai"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <br>
    <section id="main" class="outer"><article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    <div class="article-meta">
      <!--<a href="/ai4/index.html" class="article-date">
  <time datetime="2019-07-04T06:49:54.323Z" itemprop="datePublished">2019-07-04</time>
</a>-->
      <!-- 
--><!-- by blair 160724 -->
      <!-- by blair
      
        <div class="article-comment-link-wrap">
          <a href="http://shopee.ai/ai4/index.html#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/icpc/BinaryTree-1.png" width="450"></p>
<a id="more"></a>
<h2 id="1-Binary-Tree"><a href="#1-Binary-Tree" class="headerlink" title="1. Binary Tree"></a>1. Binary Tree</h2><blockquote>
<ol>
<li>重建二叉树 ok Node* f3(int* pre, int* ino, int len)       </li>
<li>树的子结构,遍历+判断, bool f5(Node* root1, Node* root2), bool son(Node* p1, Node* p2) </li>
<li>二叉树的镜像  ok 递归.   </li>
<li>从上往下打印二叉树 ok bfs      </li>
<li>二叉搜索树的后序遍历序列 bool f6(int* sec, int len)  </li>
<li>二叉树中和为某一值的路径 void f4(Node* root, int exSum, int curSum, vecotr\&lt; int >&amp; path)     </li>
<li>二叉搜索树与双向链表 void convert(Node* root, Node*&amp; pLast)   </li>
<li>二叉树的深度 bool isBalance(Node* root, int* dep)</li>
<li>平衡二叉树 bool isBalance(Node* root, int* dep)    </li>
<li><a href="https://blog.csdn.net/libin1105/article/details/48422299" target="_blank" rel="external">二叉树的下一个结点</a>  ok       </li>
<li>对称的二叉树 ok      </li>
<li>按之字形顺序打印二叉树      </li>
<li>把二叉树打印成多行  ok.   </li>
<li>序列化二叉树      </li>
<li>二叉搜索树的第k个结点 ok.   </li>
<li><a href="https://blog.csdn.net/xiaoxiaoxuanao/article/details/61918125" target="_blank" rel="external">二叉查找树节点的删除</a>.  重要</li>
<li>strcpy 手写 char* my_strcpy(char *dst, const char* src)</li>
</ol>
</blockquote>
<ul>
<li><a href="https://www.weiweiblog.cn/20tree/" target="_blank" rel="external">20tree</a></li>
</ul>
<h3 id="1-1-前序中序重建二叉树"><a href="#1-1-前序中序重建二叉树" class="headerlink" title="1.1 前序中序重建二叉树"></a>1.1 前序中序重建二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">f3</span><span class="params">(<span class="keyword">int</span>* pre, <span class="keyword">int</span>* ino, <span class="keyword">int</span> len)</span> </span>&#123; <span class="comment">// pre : 1, 2, 4, 7, 3, 5, 6, 8  ino : 4, 7, 2, 1, 5, 3, 8, 6</span></span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="literal">NULL</span> || ino == <span class="literal">NULL</span> || len &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> r_v = pre[<span class="number">0</span>];</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    root-&gt;value = r_v;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ino[i] == r_v) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;lchild = f3(pre+<span class="number">1</span>, ino, i);</span><br><span class="line">    root-&gt;rchild = f3(pre+i+<span class="number">1</span>, ino+i+<span class="number">1</span>, len<span class="number">-1</span>-i);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-树2是否是树1的子结构"><a href="#1-2-树2是否是树1的子结构" class="headerlink" title="1.2 树2是否是树1的子结构"></a>1.2 树2是否是树1的子结构</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">son</span><span class="params">(Node* p1, Node* p2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p1-&gt;value == p2-&gt;value) &#123;</span><br><span class="line">		<span class="keyword">return</span> son(p1-&gt;lchild, p2-lchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">son_tree</span><span class="params">(Node* root1, Node* root2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (root1-&gt;value == root2-&gt;child) &#123;</span><br><span class="line">		<span class="keyword">return</span> son(root1, root2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span></span><br><span class="line">	flag = son_tree(root1-&gt;lchild, root2);</span><br><span class="line">	<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">		<span class="keyword">return</span> son_tree(root1-&gt;rchild, root2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-树的镜像-amp-BFS-二叉树"><a href="#1-3-树的镜像-amp-BFS-二叉树" class="headerlink" title="1.3 树的镜像 &amp; BFS 二叉树"></a>1.3 树的镜像 &amp; BFS 二叉树</h3><h3 id="1-4-从上往下打印二叉树"><a href="#1-4-从上往下打印二叉树" class="headerlink" title="1.4 从上往下打印二叉树"></a>1.4 从上往下打印二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderBinaryTree</span><span class="params">(BinaryTreeNode *root)</span><span class="comment">//层序遍历二叉树</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    assert(root);</span><br><span class="line">    <span class="built_in">queue</span>&lt;BinaryTreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q.front()-&gt;_Lnode != <span class="literal">NULL</span>)</span><br><span class="line">            q.push(q.front()-&gt;_Lnode);</span><br><span class="line">        <span class="keyword">if</span>(q.front()-&gt;_Rnode != <span class="literal">NULL</span>)</span><br><span class="line">            q.push(q.front()-&gt;_Rnode);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;q.front()-&gt;_val&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-二叉搜索树后序遍历的结果"><a href="#1-5-二叉搜索树后序遍历的结果" class="headerlink" title="1.5 二叉搜索树后序遍历的结果"></a>1.5 二叉搜索树后序遍历的结果</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f6</span><span class="params">(<span class="keyword">int</span>* sec, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sec == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i, rv = sec[len<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sec[i] &gt; rv) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sec[j] &lt; rv) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f6(sec, i) &amp;&amp; f6(sec+i, len-i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-中和为某一值的路径"><a href="#1-6-中和为某一值的路径" class="headerlink" title="1.6 中和为某一值的路径"></a>1.6 中和为某一值的路径</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(Node*, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(Node* root, <span class="keyword">int</span> exSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V;</span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">    f4(root, exSum, curSum, V);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(Node* root, <span class="keyword">int</span> exSum, <span class="keyword">int</span> curSum, vecotr&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    curSum += root-&gt;value;</span><br><span class="line">    path.push_back(root-&gt;value);</span><br><span class="line">    <span class="keyword">if</span>(curSum == exSum &amp;&amp; root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//; 打印vector中的路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild) f4(root-&gt;lchild, exSum, curSum, path);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rchild) f4(root-&gt;rchild, exSum, curSum, path);</span><br><span class="line">    curSum -= root-&gt;value;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-二叉搜索树与双向链表"><a href="#1-7-二叉搜索树与双向链表" class="headerlink" title="1.7 二叉搜索树与双向链表"></a>1.7 二叉搜索树与双向链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(Node* root, Node*&amp; pLast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild) convert(root-&gt;lchild, pLast);</span><br><span class="line">    Node* pCur = root;</span><br><span class="line">    pCur-&gt;lchild = pLast;</span><br><span class="line">    <span class="keyword">if</span>(pLast) pLast-&gt;rchild = pCur;</span><br><span class="line">    pLast = pCur;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rchild) convert(root-&gt;rchild, pLast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-深度到是否为平衡二叉树"><a href="#1-8-深度到是否为平衡二叉树" class="headerlink" title="1.8 深度到是否为平衡二叉树"></a>1.8 深度到是否为平衡二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(Node* root, <span class="keyword">int</span>* dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *dep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isBalance(root-&gt;lchild, &amp;left) &amp;&amp; isBalance(root-&gt;rchild, &amp;right)) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = left - right;</span><br><span class="line">        <span class="keyword">if</span>(diff &gt;= <span class="number">-1</span> &amp;&amp; diff &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            *dep = <span class="number">1</span> + (left &gt; right ? left : right);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-9-二叉搜索树后序遍历的结果"><a href="#1-9-二叉搜索树后序遍历的结果" class="headerlink" title="1.9 二叉搜索树后序遍历的结果"></a>1.9 二叉搜索树后序遍历的结果</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f6</span><span class="params">(<span class="keyword">int</span>* sec, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sec == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i, rv = sec[len<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sec[i] &gt; rv) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sec[j] &lt; rv) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f6(sec, i) &amp;&amp; f6(sec+i, len-i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-10-二叉树两节点的最低公共祖先"><a href="#1-10-二叉树两节点的最低公共祖先" class="headerlink" title="1.10 二叉树两节点的最低公共祖先"></a>1.10 二叉树两节点的最低公共祖先</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Node*&gt; V1;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node*&gt; V2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getNodePath</span><span class="params">(Node* root, Node* tar, <span class="built_in">vector</span>&lt;Node*&gt;&amp; V)</span> </span>&#123; <span class="comment">// 根左右，回溯</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    V.push_back(root);</span><br><span class="line">    <span class="keyword">if</span>(root == tar) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild) flag = getNodePath(root-&gt;lchild, tar, V);</span><br><span class="line">    <span class="keyword">if</span>(!flag &amp;&amp; root-&gt;rchild) flag = getNodePath(root-&gt;rchild, tar, V);</span><br><span class="line">    <span class="keyword">if</span>(!flag) V.pop_back();</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">getCom</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node*&gt;&amp; V1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node*&gt;&amp; V2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt;::const_iterator it1 = V1.begin();</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt;::const_iterator it2 = V2.begin();</span><br><span class="line">    Node* pLast = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(it != V1.end() &amp;&amp; it2 != V2.end()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it != *it2) <span class="keyword">break</span>;</span><br><span class="line">        pLast = *it1;</span><br><span class="line">        ++it1;</span><br><span class="line">        ++it2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pLast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-具体算法"><a href="#5-具体算法" class="headerlink" title="5. 具体算法"></a>5. 具体算法</h3><h4 id="5-1-斐波拉契"><a href="#5-1-斐波拉契" class="headerlink" title="5.1 斐波拉契"></a>5.1 斐波拉契</h4><blockquote>
<ol>
<li>斐波拉契数列 ok.   </li>
<li>跳台阶  ok.   </li>
<li>变态跳台阶  2 * Fib(n-1).   </li>
<li>矩形覆盖  ok</li>
</ol>
</blockquote>
<h4 id="5-4-回溯"><a href="#5-4-回溯" class="headerlink" title="5.4 回溯"></a>5.4 回溯</h4><blockquote>
<ol>
<li>矩阵中的路径(BFS).   </li>
<li>机器人的运动范围(DFS)</li>
</ol>
</blockquote>
<h4 id="5-5-排序"><a href="#5-5-排序" class="headerlink" title="5.5 排序"></a>5.5 排序</h4><blockquote>
<ol>
<li>数组中的逆序对(归并排序).  void mergeSort(int a[], int l, int r)</li>
<li>最小的K个数(堆排序).   </li>
<li>最小的K个数(快速排序) ok</li>
</ol>
</blockquote>
<h4 id="5-6-位运算"><a href="#5-6-位运算" class="headerlink" title="5.6 位运算"></a>5.6 位运算</h4><blockquote>
<ol>
<li>二进制中1的个数  n &amp; n-1.   </li>
<li>数值的整数次方 dp.   </li>
<li>数组中只出现一次的数字 ok.  </li>
</ol>
</blockquote>
<h3 id="6-Stack-amp-Queue-amp-heap"><a href="#6-Stack-amp-Queue-amp-heap" class="headerlink" title="6. Stack &amp; Queue &amp; heap"></a>6. Stack &amp; Queue &amp; heap</h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/57153934" target="_blank" rel="external">【NLP/AI算法面试必备-2】NLP/AI面试全记录（持续更新）</a></li>
<li><a href="https://www.zhihu.com/people/lou-jie-9/posts" target="_blank" rel="external">【NLP/AI算法面试必备-1】学习NLP/AI，必须深入理解“神经网络及其优化问题”</a></li>
<li><a href="https://www.zhihu.com/people/lou-jie-9/posts" target="_blank" rel="external">JayLouNLP算法工程师</a></li>
<li><a href="https://coolshell.cn/articles/3345.html" target="_blank" rel="external">140个GOOGLE的面试题</a></li>
</ul>

      
    
    </div>
    
      <div class="article-toc">
        <h3>Contents</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Binary-Tree"><span class="toc-number"></span> <span class="toc-text">1. Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-前序中序重建二叉树"><span class="toc-number"></span> <span class="toc-text">1.1 前序中序重建二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-树2是否是树1的子结构"><span class="toc-number"></span> <span class="toc-text">1.2 树2是否是树1的子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-树的镜像-amp-BFS-二叉树"><span class="toc-number"></span> <span class="toc-text">1.3 树的镜像 & BFS 二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-从上往下打印二叉树"><span class="toc-number"></span> <span class="toc-text">1.4 从上往下打印二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-二叉搜索树后序遍历的结果"><span class="toc-number"></span> <span class="toc-text">1.5 二叉搜索树后序遍历的结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-中和为某一值的路径"><span class="toc-number"></span> <span class="toc-text">1.6 中和为某一值的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-二叉搜索树与双向链表"><span class="toc-number"></span> <span class="toc-text">1.7 二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-深度到是否为平衡二叉树"><span class="toc-number"></span> <span class="toc-text">1.8 深度到是否为平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-二叉搜索树后序遍历的结果"><span class="toc-number"></span> <span class="toc-text">1.9 二叉搜索树后序遍历的结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-二叉树两节点的最低公共祖先"><span class="toc-number"></span> <span class="toc-text">1.10 二叉树两节点的最低公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-具体算法"><span class="toc-number"></span> <span class="toc-text">5. 具体算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-斐波拉契"><span class="toc-number"></span> <span class="toc-text">5.1 斐波拉契</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-回溯"><span class="toc-number"></span> <span class="toc-text">5.4 回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-排序"><span class="toc-number"></span> <span class="toc-text">5.5 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-位运算"><span class="toc-number"></span> <span class="toc-text">5.6 位运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Stack-amp-Queue-amp-heap"><span class="toc-number"></span> <span class="toc-text">6. Stack & Queue & heap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number"></span> <span class="toc-text">Reference</span></a></li></ol>
      </div>
    
    
      <footer class="article-footer">
        <!-- <div class="well" style="width:100px; height:30px;"></div>  by blair-->
        
 <!-- by blair add 160724-->
        <!--
        <div style="width:100px; height:30px;"></div> by blair add 160724
        -->
        

      </footer>
    
  </div>
  
    
  
</article>

<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Blair Chan&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/52binge/hexo-theme-blairos">blairos</a>
    </div>
  </div>
</footer>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML,http://myserver.com/MathJax/config/local/local.js">
</script>

    
<script type="text/javascript"> <!-- add by blair 0724 type=text/javascript -->
  var disqus_shortname = 'blairos-sn';
  
  var disqus_url = 'http://shopee.ai/ai4/index.html';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
