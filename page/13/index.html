<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Auckland New Zealand</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Everyone should not forget his dream">
<meta property="og:type" content="website">
<meta property="og:title" content="Auckland New Zealand">
<meta property="og:url" content="http:&#x2F;&#x2F;iequa.com&#x2F;page&#x2F;13&#x2F;index.html">
<meta property="og:site_name" content="Auckland New Zealand">
<meta property="og:description" content="Everyone should not forget his dream">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <!-- blair add baidu tongji start... @2017.10.03 -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8864dc75a81a27b7e44c00138af95d66";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- blair add baidu tongji end ! @2017.10.03 -->

<header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;" target="_blank" rel="noopener"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/ai1">AI</a>
        
          <a class="main-nav-link" href="/tensorflow">TF/Keras</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://iequa.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <br>
    <section id="main" class="outer">
      <article id="post-chatbot/chatbot-research1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/08/11/chatbot/chatbot-research1/"><strong>Chatbot Research 1 - 聊天机器人的行业综述</strong></a>
      <small class=article-date-index>&nbsp; 2017-08-11</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/08/11/chatbot/chatbot-research1/" class="article-date">
  <time datetime="2017-08-11T06:00:21.000Z" itemprop="datePublished">2017-08-11</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/chatbot/">chatbot</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/08/11/chatbot/chatbot-research1/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>英文原文： <a href="http://www.wildml.com/2016/04/deep-learning-for-chatbots-part-1-introduction/" target="_blank" rel="noopener">《Deep Learning For Chatbots, Part 1 - Introduction》</a></p>
<p>中文翻译： <a href="http://www.jeyzhang.com/deep-learning-for-chatbots-1.html" target="_blank" rel="noopener">《聊天机器人中的深度学习导读》</a></p>
<p>&lt;!-- more --&gt;</p>
<p>这篇博文主要概述了目前聊天机器人主要用到的技术，从宏观上进行介绍，不涉及具体的技术细节。</p>
<p>聊天机器人 (Chatbot)，也被称为对话引擎或者对话系统，是目前的热点之一。微软公司在聊天机器人上的投入巨大（<a href="https://www.bloomberg.com/features/2016-microsoft-future-ai-chatbots/" target="_blank" rel="noopener">链接</a>），著名产品有小冰 (xiaoice)、bot framework等，其他公司也纷纷在这个领域发力，如Facebook的M，苹果公司的Siri等等。此外，一大批的创业公司发布了类似的产品，例如客户应用<a href="https://operator.com/" target="_blank" rel="noopener">Operator</a>，<a href="https://x.ai/" target="_blank" rel="noopener">x.ai</a>，bot framework <a href="http://chatfuel.com/" target="_blank" rel="noopener">Chatfuel</a>，bot开发工具 <a href="http://howdy.ai/botkit/" target="_blank" rel="noopener">Howdy’s Botkit</a>。微软也发布了供开发者使用的 <a href="https://dev.botframework.com/" target="_blank" rel="noopener">bot developer framework</a></p>
<p>还有一些应用案例，列举如下：</p>
<ul>
<li>案例:语音助手 Siri</li>
<li>案例:餐饮 Pizza Hut</li>
<li>案例:健身 Fitness Tips</li>
<li>案例:旅游 <a href="https://viewfinder.expedia.com/features/introducing-expedia-bot-skype/" target="_blank" rel="noopener">expedia</a></li>
<li>案例:医疗 <a href="https://www.healthtap.com/" target="_blank" rel="noopener">healthtap</a></li>
<li>案例:新闻 <a href="https://qzprod.wordpress.com/" target="_blank" rel="noopener">wordpress</a></li>
<li>案例:财经 <a href="https://meetcleo.com/" target="_blank" rel="noopener">meetcleo</a></li>
</ul>
<p>许多公司希望能开发出与用户进行自然语言式对话的机器人，并且声称使用了NLP和深度学习相关技术使之成为可能，然而这并不容易实现。在这个博文系列中，我将会重温一些被用于聊天机器人中的深度学习技术，披露出目前技术能够解决或者可能解决的问题以及几乎难以解决的问题。这篇文章是个概述，在接下来的博文中将介绍具体的技术细节。</p>
<h2>1. 模型分类</h2>
<h3>1.1 检索技术模型 VS 生成式模型</h3>
<p><strong>基于检索技术的模型</strong>较为简单，主要是根据用户的输入和上下文内容，使用了知识库（存储了事先定义好的回复内容）和一些启发式方法来得到一个合适的回复。启发式方法简单的有基于规则的表达式匹配，复杂的有一些机器学习里的分类器。这些系统不能够生成任何新的内容，只是从一个固定的数据集中找到合适的内容作为回复。</p>
<p><strong>生成式模型</strong>则更加复杂，它不依赖于预定义好的回复内容，而是通过<strong>抓取(Scratch)<strong>的方法生成新的回复内容。生成式模型典型的有</strong>基于机器翻译模型</strong>的，与传统机器翻译模型不同的是，生成式模型的任务不是将一句话翻译成其他语言的一句话，而是将<strong>用户的输入[翻译]为一个回答(response)</strong></p>
<p>&lt;img src=&quot;/images/chatbot/chatbot-1_1.png&quot; width=&quot;800&quot; /&gt;</p>
<h3>1.2 模型分类总结</h3>
<p>以上两种模型均有优缺点。对于基于检索技术的模型，由于使用了知识库且数据为预先定义好的，因此进行回复的内容语法上较为通顺，较少出现语法错误；但是基于检索技术的模型中没有会话概念，不能结合上下文给出更加[智能]的回复。而生成式模型则更加[智能]一些，它能够更加有效地利用上下文信息从而知道你在讨论的东西是什么；然而生成式模型比较难以训练，并且输出的内容经常存在一些语法错误（尤其对于长句子而言），以及模型训练需要大规模的数据。</p>
<p>深度学习技术都能够用于基于检索技术的模型和生成式模型中，但是目前的研究热点在生成式模型上。深度学习框架例如Sequence to Sequence非常适合用来生成文本，非常多的研究者希望能够在这个领域取得成功。然而目前这一块的研究还在初期阶段，工业界的产品更多的还是使用基于检索计算的模型。</p>
<h2>2. 问题分类</h2>
<h3>2.1 短对话 VS 长对话</h3>
<p>直观上处理长对话内容将更加困难，这是因为你需要在当前对话的情境下知道之前的对话说过什么。如果是一问一答的形式，技术上这将简单的多。通常对于客服对话而言，长对话更加常见，一次对话中往往会伴随着多个关联问题。</p>
<h3>2.2 开放域 VS 特定领域</h3>
<p>面向开放域的聊天机器人技术面临更多困难，这是因为会话可能涉及的面太广，没有一个清晰的目标和意图。在一些社交网站例如Twitter和Reddit上的会话是属于开放域的，会话涉及的主题多种多样，需要的知识量也将非常巨大。</p>
<p>面向特定领域的相关技术则相对简单一些，这是因为特定领域给会话的主题进行了限制，目标和意图也更加清晰，典型的例子有客服系统助手和购物助手。这些系统通常是为了完成某些特定任务，尽管用户在该系统中也能够问些其他方面的东西，但是系统并不会给出相应的回复。</p>
<h2>3. 面临的挑战</h2>
<p>下面介绍一下聊天机器人技术所面临的挑战。</p>
<h3>3.1 如何结合上下文信息</h3>
<p>为了产生质量更高的回复，聊天机器人系统通常需要利用一些上下文信息(Context)，这里的上下文信息包括了对话过程中的语言上下文信息和用户的身份信息等。在长对话中人们关注的是之前说了什么内容以及产生了什么内容的交换，这是语言上下文信息的典型。常见的方法是将一个会话转化为向量形式，但这对长会话而言是困难的。论文Building End-To-End Dialogue Systems Using Generative Hierarchical Neural Network Models和Attention with Intention for a Neural Network Conversation Model中的实验结果表明了这一点。另外，可以结合的上下文信息还包括会话进行时的日期地点信息、用户信息等。</p>
<h3>3.2 语义一致性</h3>
<p>理论上来说，机器人面对相同语义而不同形式的问题应该给予一致的回复，例如这两个问题[How old are you?]和[What’s your age?]。这理解起来是简单的，但却是学术界目前的难题之一（如下图）。许多系统都试图对相同语义而不同形式的问题给予语义上合理的回复，但却没有考虑一致性，最大的原因在于训练模型的数据来源于大量不同的用户，这导致机器人失去了固定统一的人格。论文A Persona-Based Neural Conversation Model中提及的模型旨在创建具有固定统一人格的机器人。</p>
<p>&lt;img src=&quot;/images/chatbot/chatbot-1_2.png&quot; width=&quot;400&quot; /&gt;</p>
<h3>3.3 对话模型的评测</h3>
<p>评价一个对话模型的好坏在于它是否很好地完成了某项任务，例如在对话中解决了客户的问题。这样的训练数据需要人工标注和评测，所以获取上需要一定人力代价。有时在开放域中的对话系统也没有一个清晰的优化目标。用于机器翻译的评测指标BLEU不能适用于此，是因为它的计算基础是语言表面上的匹配程度，而对话中的回答可以是完全不同词型但语义通顺的语句。论文<a href="https://arxiv.org/abs/1603.08023" target="_blank" rel="noopener">How NOT To Evaluate Your Dialogue System: An Empirical Study of Unsupervised Evaluation Metrics for Dialogue Response Generation</a>中给出结论，目前常用的评测指标均与人工评测无关。</p>
<h3>3.4 意图和回复多样性</h3>
<p>生成式模型中的一个普遍问题是，它们都想要生成一些通用的回答，例如[That’s great!]和[I don’t know]这样的可以应付许多的用户询问。早期的Google智能回复基本上以[I love you]回复所有的东西链接，这是一些模型最终训练出来的结果，原因在于训练数据和训练的优化目标。因此，有些研究学者开始关注<a href="http://arxiv.org/abs/1510.03055" target="_blank" rel="noopener">如何提升机器人的回复的多样性</a>，然而人们在对话过程中的回复与询问有一定特定关系，是有一定意图的，而许多面向开放域的机器人不具备特定的意图。</p>
<h3>3.5 实际效果</h3>
<p>以目前的研究水平所制造的机器人能够取得的效果如何？使用基于检索技术的显然无法制作出面向开放域的机器人，这是因为你不能编写覆盖所有领域的语料；而生成式的面向开放域的机器人还属于通用人工智能(Artifical General Intelligence, AGI)水平，距离理想状态还相距甚远，但相关研究学者还在致力于此。</p>
<p>对于特定领域的机器人，基于检索的技术和生成式模型都能够利用。但是对于长对话的情境，也面临许多困难。</p>
<p>在最近对<a href="https://www.seattletimes.com/business/baidu-research-chief-andrew-ng-fixed-on-self-taught-computers-self-driving-cars/" target="_blank" rel="noopener">Andrew NG的采访</a>中，NG提到：</p>
<blockquote>
<p>目前深度学习的价值主要体现在能够获取大量数据的特定领域。</p>
<p>目前一个无法做的事情是产生一个有意义的对话。</p>
<p>详细： 当今深度学习的价值在你可以获得许多数据的狭窄领域内。有一件事它做不到：进行有意义的对话。存在一些演示，并且如果你仔细挑选这些对话，看起来就像它正在进行有意义的对话，但是如果你亲自尝试，它就会快速偏离轨道。</p>
</blockquote>
<p>许多创业公司声称只要有足够多的数据，就能够产生自动智能的对话系统。然而，目前的水平生产出面向一个特定的子领域的对话应用（如利用Uber打车），而对于一个稍微开放点的领域就难以实现了（如自动销售）。但是，帮助用户提供自动回复建议以及语法纠正还是可行的。</p>
<p>使用基于检索技术的对话系统更加可控和稳定，给出的回复出现语法错误的几率更低。而使用生成式模型的风险在于回复不可控，且容易出现一些风险，例如<a href="http://www.businessinsider.com/microsoft-deletes-racist-genocidal-tweets-from-ai-chatbot-tay-2016-3" target="_blank" rel="noopener">微软的Tay</a>。</p>
<h2>4. 即将到来的事情和阅读列表</h2>
<p>在之后的博文中将具体介绍深度学习方面的技术细节。提前阅读下面的文章将会对后面的学习更加有帮助。</p>
<ul>
<li>
<p><a href="http://arxiv.org/abs/1503.02364" target="_blank" rel="noopener">Neural Responding Machine for Short-Text Conversation (2015-03)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1506.05869" target="_blank" rel="noopener">A Neural Conversational Model (2015-06)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1506.06714" target="_blank" rel="noopener">A Neural Network Approach to Context-Sensitive Generation of Conversational Responses (2015-06)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1506.08909" target="_blank" rel="noopener">The Ubuntu Dialogue Corpus: A Large Dataset for Research in Unstructured Multi-Turn Dialogue Systems (2015-06)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1507.04808" target="_blank" rel="noopener">Building End-To-End Dialogue Systems Using Generative Hierarchical Neural Network Models (2015-07)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1510.03055" target="_blank" rel="noopener">A Diversity-Promoting Objective Function for Neural Conversation Models (2015-10)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1510.08565" target="_blank" rel="noopener">Attention with Intention for a Neural Network Conversation Model (2015-10)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1510.03753" target="_blank" rel="noopener">Improved Deep Learning Baselines for Ubuntu Corpus Dialogs (2015-10)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1512.05742" target="_blank" rel="noopener">A Survey of Available Corpora for Building Data-Driven Dialogue Systems (2015-12)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1603.06393" target="_blank" rel="noopener">Incorporating Copying Mechanism in Sequence-to-Sequence Learning (2016-03)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1603.06155" target="_blank" rel="noopener">A Persona-Based Neural Conversation Model (2016-03)</a></p>
</li>
<li>
<p><a href="https://arxiv.org/abs/1603.08023" target="_blank" rel="noopener">How NOT To Evaluate Your Dialogue System: An Empirical Study of Unsupervised Evaluation Metrics for Dialogue Response Generation (2016-03)</a></p>
</li>
</ul>
<p>数据驱动的意义是：</p>
<ul>
<li>算法越简单，解释性越好</li>
<li>数据量足够大，覆盖的真实世界的大部分场景</li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-ml/naive-bayes-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/08/10/ml/naive-bayes-1/"><strong>Naive Bayes * 垃圾邮件分类</strong></a>
      <small class=article-date-index>&nbsp; 2017-08-10</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/08/10/ml/naive-bayes-1/" class="article-date">
  <time datetime="2017-08-09T23:08:21.000Z" itemprop="datePublished">2017-08-10</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/machine-learning/">machine-learning</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/08/10/ml/naive-bayes-1/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>贝叶斯方法是一个历史悠久，有着坚实的理论基础的方法，同时处理很多问题时直接而又高效, 很多高级 NLP 模型也可以从它演化而来。因此，学习贝叶斯方法，是研究 NLP 问题的一个非常好的切入口。</p>
<p>&lt;!--more--&gt;</p>
<h2>1. 贝叶斯</h2>
<p>$$
P(Y|X)=\frac{P(X|Y)P(Y)}{P(X)}
$$</p>
<h2>2. 贝叶斯公式</h2>
<p>贝叶斯公式就一行：</p>
<p>$$
P(Y|X)=\frac{P(X|Y)P(Y)}{P(X)}
$$</p>
<p>它其实是由以下的联合概率公式推导出来：</p>
<p>$$
P(Y,X)=P(Y|X)P(X)=P(X|Y)P(Y)
$$</p>
<p>其中 $P(Y)$ 叫做先验概率， $P(Y|X)$ 叫做后验概率， $P(Y,X)$ 叫做联合概率。</p>
<h2>3. 机器学习视角理解贝叶斯公式</h2>
<p>把 $X$ 理解成 “$有某 feature$”
把 $Y$ 理解成 “$属于某类 label$”</p>
<blockquote>
<p>一般机器学习为题中都是 $X$ =&gt; 特征, $Y$ =&gt; 结果 对吧。</p>
</blockquote>
<blockquote>
<p>在最简单的二分类问题(是与否判定)下，我们将 $Y$ 理解成 $“属于某类”$ 的标签。
于是贝叶斯公式就变形成了下面的样子:</p>
</blockquote>
<p>$$
P(“属于某类”|“具有某特征”)=\frac{P(“具有某特征”|“属于某类”)P(“属于某类”)}{P(“具有某特征”)}
$$</p>
<p>而我们二分类问题的最终目的就是要判断 $P(“属于某类”|“具有某特征”)$ 是否大于1/2就够了。贝叶斯方法把计算 “$具有某特征的条件下属于某类$” 的概率转换成需要计算 “$属于某类的条件下具有某特征$” 的概率，而后者获取方法就简单多了，我们只需要找到一些包含已知特征标签的样本，即可进行训练。而样本的类别标签都是明确的，所以贝叶斯方法在机器学习里属于<code>有监督学习方法</code>。</p>
<h2>4. 垃圾邮件识别</h2>
<p>举个栗子 🌰</p>
<p>我们现在要对邮件进行分类，识别垃圾邮件和普通邮件，如果我们选择使用朴素贝叶斯分类器，那目标就是判断 $P(“垃圾邮件”|“具有某特征”)$ 是否大于1/2。</p>
<p>假设我们有垃圾邮件和正常邮件各1万封作为训练集。需要判断以下这个邮件是否属于垃圾邮件：</p>
<blockquote>
<p>“我司可办理正规发票（保真）17%增值税发票点数优惠！”</p>
</blockquote>
<p>也就是判断概率 $P(“垃圾邮件”|“我司可办理正规发票（保真）17%增值税发票点数优惠！”)$ 是否大于1/2。</p>
<p>$$
P = \frac{垃圾邮件中出现这句话的次数}{垃圾邮件中出现这句话的次数+正常邮件中出现这句话的次数}
$$</p>
<blockquote>
<p>咳咳，有木有发现，转换成的这个概率，计算的方法：就是写个计数器，然后+1 +1 +1统计出所有垃圾邮件和正常邮件中出现这句话的次数啊！！！</p>
</blockquote>
<h2>5. 分词</h2>
<p>一个很悲哀但是很现实的结论：<code>训练集是有限的，而句子的可能性则是无限的。所以覆盖所有句子可能性的训练集是不存在的</code>。</p>
<p>所以解决方法是？ $句子的可能性无限，但是词语就那么些$！！汉语常用字2500个，常用词语也就56000个(你终于明白小学语文老师的用心良苦了)。按人们的经验理解，两句话意思相近并不强求非得每个字、词语都一样。比如 $“我司可办理正规发票，17%增值税发票点数优惠！”$，这句话就比之前那句话少了“（保真）”这个词，但是意思基本一样。如果把这些情况也考虑进来，那样本数量就会增加，这就不方便我们计算了。</p>
<p>于是，我们可以不拿句子作为特征，而是拿句子里面的词语（组合）作为特征去考虑。比如 “$正规发票$” 可以作为一个单独的词语，“$增值税$” 也可以作为一个单独的词语等等。</p>
<blockquote>
<p>句子“我司可办理正规发票，17%增值税发票点数优惠！”就可以变成（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)）。</p>
</blockquote>
<p>于是你接触到了中文NLP中，最最最重要的技术之一：<strong><code>分词</code></strong>！！！也就是把一整句话拆分成更细粒度的词语来进行表示。另外，分词之后去除标点符号、数字甚至无关成分(停用词)是特征预处理中的一项技术。</p>
<p>中文分词是一个专门的技术领域(我不会告诉你某搜索引擎厂码砖工有专门做分词的！！！)</p>
<p>我们观察$（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)$，这可以理解成一个向量：向量的每一维度都表示着该 $特征词$ 在文本中的特定位置存在。这种将特征拆分成更小的单元，依据这些更灵活、更细粒度的特征进行判断的思维方式，在自然语言处理与机器学习中都是非常常见又有效的。</p>
<p>因此贝叶斯公式就变成了：</p>
<p>$$
P(“垃圾邮件”|（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)）
$$</p>
<p>$$
=\frac{P(（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)|”垃圾邮件”）P(“垃圾邮件”)}{P(（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)) }
$$</p>
<hr>
<p>$$
P(“正常邮件”|（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)）
$$</p>
<p>$$
=\frac{P(（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)|”正常邮件”）P(“正常邮件”)}{P(（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)) }
$$</p>
<h2>6. 条件独立假设</h2>
<p>下面我们马上会看到一个非常简单粗暴的假设。</p>
<p>$P(（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)|”垃圾邮件”）$ 依旧不够好求，我们引进一个很朴素的近似。为了让公式显得更加紧凑，我们令字母 <code>S</code> 表示“垃圾邮件”,令字母 <code>H</code> 表示“正常邮件”。近似公式如下：</p>
<p>$$
P(（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)|S）
$$</p>
<p>$$
=P(“我”|S）×P(“司”|S）×P(“可”|S）×P(“办理”|S）×P(“正规发票”|S）
$$</p>
<p>$$
×P(“保真”|S）×P(“增值税”|S）×P(“发票”|S）×P(“点数”|S）×P(“优惠”|S)
$$</p>
<p>这就是传说中的条件独立假设。基于“正常邮件”的条件独立假设的式子与上式类似，此处省去。接着，将条件独立假设代入上面两个相反事件的贝叶斯公式。</p>
<p>于是我们就只需要比较以下两个式子的大小：</p>
<p>$$
C = P(“我”|S)P(“司”|S)P(“可”|S)P(“办理”|S)P(“正规发票”|S)
$$</p>
<p>$$
×P(“保真”|S)P(“增值税”|S)P(“发票”|S)P(“点数”|S)P(“优惠”|S)P(“垃圾邮件”)
$$</p>
<hr>
<p>$$
\overline{C}=P(“我”|H)P(“司”|H)P(“可”|H)P(“办理”|H)P(“正规发票”|H)
$$</p>
<p>$$
×P(“保真”|H)P(“增值税”|H)P(“发票”|H)P(“点数”|H)P(“优惠”|H)P(“正常邮件”)
$$</p>
<p>厉(wo)害(cao)！酱紫处理后式子中的每一项都特别好求！只需要分别统计各类邮件中该关键词出现的概率就可以了！！！比如：</p>
<blockquote>
<p>$$
P(“发票”|S）=\frac{垃圾邮件中所有“发票”的次数}{垃圾邮件中所有词语的次数}
$$</p>
</blockquote>
<p>统计次数非常方便，而且样本数量足够大，算出来的概率比较接近真实。于是垃圾邮件识别的问题就可解了。</p>
<h2>7. Naive Bayes，“Naive”在何处？</h2>
<p>加上条件独立假设的贝叶斯方法就是朴素贝叶斯方法（Naive Bayes）。 Naive的发音是“乃一污”，意思是“朴素的”、“幼稚的”、“蠢蠢的”。咳咳，也就是说，大神们取名说该方法是一种比较萌蠢的方法，为啥？</p>
<p>将句子（“我”,“司”,“可”,“办理”,“正规发票”) 中的 （“我”,“司”）与（“正规发票”）调换一下顺序，就变成了一个新的句子（“正规发票”,“可”,“办理”, “我”, “司”)。新句子与旧句子的意思完全不同。但由于乘法交换律，朴素贝叶斯方法中算出来二者的条件概率完全一样！计算过程如下：</p>
<p>$$
P(（“我”,“司”,“可”,“办理”,“正规发票”)|S) = P(“我”|S)P(“司”|S)P(“可”|S)P(“办理”|S)P(“正规发票”|S)
$$</p>
<p>$$
=P(“正规发票”|S)P(“可”|S)P(“办理”|S)P(“我”|S)P(“司”|S） =P(（“正规发票”,“可”,“办理”, “我”, “司”)|S)
$$</p>
<p>也就是说，在朴素贝叶斯眼里，“<code>我司可办理正规发票</code>” 与 “<code>正规发票可办理我司</code>” 完全相同。朴素贝叶斯失去了词语之间的顺序信息。这就相当于把所有的词汇扔进到一个袋子里随便搅和，贝叶斯都认为它们一样。因此这种情况也称作词袋子模型(<code>bag of words</code>)。</p>
<p>词袋子模型与人们的日常经验完全不同。比如，在条件独立假设的情况下，“<code>武松打死了老虎</code>” 与 “<code>老虎打死了武松</code>” 被它认作一个意思了。恩，朴素贝叶斯就是这么单纯和直接，对比于其他分类器，好像是显得有那么点萌蠢</p>
<h2>8. 简单高效，吊丝逆袭</h2>
<p>虽然说朴素贝叶斯方法萌蠢萌蠢的，但实践证明在垃圾邮件识别的应用还令人诧异地好。Paul Graham先生自己简单做了一个朴素贝叶斯分类器，“1000封垃圾邮件能够被过滤掉995封，并且没有一个误判”。（Paul Graham《黑客与画家》）</p>
<p>那个...效果为啥好呢？</p>
<blockquote>
<p>“有人对此提出了一个理论解释，并且建立了什么时候朴素贝叶斯的效果能够等价于非朴素贝叶斯的充要条件，这个解释的核心就是：有些独立假设在各个分类之间的分布都是均匀的所以对于似然的相对大小不产生影响；即便不是如此，也有很大的可能性各个独立假设所产生的消极影响或积极影响互相抵消，最终导致结果受到的影响不大。具体的数学公式请参考[这篇 paper][2]。”（刘未鹏《：平凡而又神奇的贝叶斯方法》）</p>
</blockquote>
<p>恩，这个分类器中最简单直接看似萌蠢的小盆友『朴素贝叶斯』，实际上却是简单、实用、且强大的。</p>
<h2>9. 处理重复词语的三种方式</h2>
<p>我们之前的 &lt;font color=blue&gt; 垃圾邮件向量（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”) &lt;/font&gt;，其中每个词都不重复。而这在现实中其实很少见。因为如果文本长度增加，或者分词方法改变，必然会有许多词重复出现，因此需要对这种情况进行进一步探讨。比如以下这段邮件：</p>
<blockquote>
<p>“代开发票。增值税发票，正规发票。” 分词后为向量： （“代开”,“发票”,“增值税”,“发票”,“正规”,“发票”）</p>
</blockquote>
<p>其中“发票”重复了三次。</p>
<h3>9.1 多项式模型</h3>
<p>如果我们考虑重复词语的情况，&lt;font color=blue&gt;重复的词语我们视为其出现多次&lt;/font&gt;，直接按条件独立假设的方式推导，则有</p>
<p>$$
P(（“代开”,“发票”,“增值税”,“发票”,“正规”,“发票”)|S）
$$</p>
<p>$$
=P(“代开””|S)P(“发票”|S)P(“增值税”|S)P(“发票”|S)P(“正规”|S)P(“发票”|S）
$$</p>
<p>$$
=P(“代开””|S)P^3(“发票”|S)P(“增值税”|S)P(“正规”|S)<br>
$$</p>
<blockquote>
<p>注意这项 $P^3(“发票”|S)$</p>
</blockquote>
<h3>9.2 伯努利模型</h3>
<p>另一种更加简化的方法是将重复的词语都视为其只出现1次，</p>
<p>$$
P(（“代开”,“发票”,“增值税”,“发票”,“正规”,“发票”)|S）
$$</p>
<p>$$
=P(“发票”|S)P(“代开””|S)P(“增值税”|S)P(“正规”|S）
$$</p>
<p>统计计算 $P(“词语”|S)$ 时也是如此。</p>
<p>$$
P(“发票”|S）=\frac{出现“发票”的垃圾邮件的封数}{每封垃圾邮件中所有词出现次数（出现了只计算一次）的总和}
$$</p>
<p>这样的模型叫作 &lt;font color=blue&gt;伯努利模型&lt;/font&gt;（又称为二项独立模型）。这种方式更加简化与方便。当然它丢失了词频的信息，因此效果可能会差一些。</p>
<h3>9.3 混合模型</h3>
<p>第三种方式是在计算句子概率时，不考虑重复词语出现的次数，但是在统计计算词语的概率$P(“词语”|S)$ 时，却考虑重复词语的出现次数，这样的模型可以叫作混合模型。</p>
<p><img src="/images/ml/bayes/bayes-03.jpg" alt=""></p>
<p>具体实践中采用那种模型，关键看具体的业务场景，一个简单经验是，对于垃圾邮件识别，混合模型更好些。</p>
<h2>10. 去除停用词与选择关键词</h2>
<p>我们继续观察**（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)** 这句话。其实，像**“我”、“可”<strong>之类词其实非常中性，无论其是否出现在垃圾邮件中都无法帮助判断的有用信息。所以可以直接不考虑这些典型的词。这些无助于我们分类的词语叫作 “停用词”（<code>Stop Words</code>）。这样可以减少我们训练模型、判断分类的时间。 于是之前的句子就变成了</strong>（“司”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”) **。</p>
<p>我们进一步分析。以人类的经验，其实 <strong>“正规发票”、“发票”</strong> 这类的词如果出现的话，邮件作为垃圾邮件的概率非常大，可以作为我们区分垃圾邮件的“关键词”。而像 <strong>“司”、“办理”、“优惠”</strong> 这类的词则有点鸡肋，可能有助于分类，但又不那么强烈。如果想省事做个简单的分类器的话，则可以直接采用“关键词”进行统计与判断，剩下的词就可以先不管了。于是之前的垃圾邮件句子就变成了**（“正规发票”,“发票”)** 。这样就更加减少了我们训练模型、判断分类的时间，速度非常快。</p>
<p><strong>“停用词”和“关键词”一般都可以提前靠人工经验指定</strong>。不同的“停用词”和“关键词”训练出来<strong>的分类器</strong>的效果也会有些差异。</p>
<h2>11. 浅谈平滑技术</h2>
<p>我们来说个问题(中文NLP里问题超级多)，比如在计算以下独立条件假设的概率：</p>
<p>$$
P(（“我”,“司”,“可”,“办理”,“正规发票”)|S)
$$</p>
<p>$$
=P(“我”|S)P(“司”|S)P(“可”|S)P(“办理”|S)P(“正规发票”|S）
$$</p>
<p>我们扫描一下训练集，发现 <strong>“正规发票”这个词从出现过！！！，于是 $P(“正规发票”|S）=0$ ...问题严重了，整个概率都变成0了！！！朴素贝叶斯方法面对一堆0，很凄惨地失效了...更残酷的是</strong> 这种情况其实很常见，<strong>因为哪怕训练集再大，也可能有覆盖不到的词语。本质上还是</strong>样本数量太少，不满足大数定律，计算出来的概率失真。为了解决这样的问题，一种分析思路就是直接不考虑这样的词语，但这种方法就相当于默认给 $P(“正规发票”|S）$ 赋值为1。其实效果不太好，大量的统计信息给浪费掉了。我们进一步分析，既然可以默认赋值为1，为什么不能默认赋值为一个很小的数？这就是平滑技术的基本思路，依旧保持着一贯的作风，朴实/土但是直接而有效。</p>
<p>对于伯努利模型，$P(“正规发票”|S)$ 的一种平滑算法是：</p>
<p>$$
P(“正规发票”|S）=\frac{出现“正规发票”的垃圾邮件的封数+1}{每封垃圾邮件中所有词出现次数（出现了只计算一次）的总和+2}
$$</p>
<p>对于多项式模型，$P(“正规发票”| S)$ 的一种平滑算法是：</p>
<p>$$
P(“发票”|S）=\frac{每封垃圾邮件中出现“发票”的次数的总和+1}{每封垃圾邮件中所有词出现次数（计算重复次数）的总和+被统计的词表的词语数量}
$$</p>
<p>说起来，平滑技术的种类其实非常多，有兴趣的话回头我们专门拉个专题讲讲好了。这里只提一点，就是所有的<strong>平滑技术都是给未出现在训练集中的词语一个估计的概率，而相应地调低其他已经出现的词语的概率</strong>。</p>
<p>平滑技术是因为数据集太小而产生的现实需求。<strong>如果数据集足够大，平滑技术对结果的影响将会变小</strong>。</p>
<h2>12. 内容小结</h2>
<p>我们找了个最简单常见的例子：垃圾邮件识别，说明了一下朴素贝叶斯进行文本分类的思路过程。基本思路是先区分好训练集与测试集，对文本集合进行分词、去除标点符号等特征预处理的操作，然后使用条件独立假设，将原概率转换成词概率乘积，再进行后续的处理。</p>
<p>$$
贝叶斯公式 + 条件独立假设 = 朴素贝叶斯方法
$$</p>
<p>基于对重复词语在训练阶段与判断（测试）阶段的三种不同处理方式，我们相应的有伯努利模型、多项式模型和混合模型。在训练阶段，如果样本集合太小导致某些词语并未出现，我们可以采用平滑技术对其概率给一个估计值。而且并不是所有的词语都需要统计，我们可以按相应的“停用词”和“关键词”对模型进行进一步简化，提高训练和判断速度。</p>
<h2>13. 匹配关键词识别spam？</h2>
<p>有同学可能会问：“何必费这么大劲算那么多词的概率？直接看邮件中有没有‘代开发票’、‘转售发票’之类的关键词不就得了？如果关键词比较多就认为是垃圾邮件呗。”</p>
<p>其实关键词匹配的方法如果有效的话真不必用朴素贝叶斯。毕竟这种方法简单嘛，就是一个字符串匹配。从历史来看，之前没有贝叶斯方法的时候主要也是用关键词匹配。但是这种方法准确率太低。我们在工作项目中也尝试过用关键词匹配的方法去进行文本分类，发现大量误报。感觉就像扔到垃圾箱的邮件99%都是正常的！这样的效果不忍直视。而加一个朴素贝叶斯方法就可能把误报率拉低近一个数量级，体验好得不要不要的。</p>
<p>另一个原因是词语会随着时间不断变化。发垃圾邮件的人也不傻，当他们发现自己的邮件被大量屏蔽之后，也会考虑采用新的方式，如变换文字、词语、句式、颜色等方式来绕过反垃圾邮件系统。比如对于垃圾邮件“我司可办理正规发票，17%增值税发票点数优惠”,他们采用<strong>火星文：“涐司岢办理㊣規髮票，17%增値稅髮票嚸數優蕙”</strong>，那么字符串匹配的方法又要重新找出这些火星文，一个一个找出关键词，重新写一些匹配规则。更可怕的是，这些规则可能相互之间的耦合关系异常复杂，要把它们梳理清楚又是大一个数量级的工作量。等这些规则失效了又要手动更新新的规则……<strong>无穷无尽猫鼠游戏最终会把猫给累死</strong>。</p>
<p>而朴素贝叶斯方法却显示出无比的优势。因为它是基于统计方法的，只要训练样本中有更新的垃圾邮件的新词语，哪怕它们是火星文，都能自动地把哪些更敏感的词语（如“髮”、“㊣”等）给凸显出来，并根据统计意义上的敏感性给他们分配适当的权重 ，这样就不需要什么人工了，非常省事。你只需要时不时地拿一些最新的样本扔到训练集中，重新训练一次即可。</p>
<blockquote>
<p>小补充一下，对于火星文、同音字等替代语言，一般的分词技术可能会分得不准，最终可能只把一个一个字给分出来，成为“分字”。效果可能不会太好。也可以用过n-gram之类的语言模型，拿到最常见短语。当然，对于英文等天生自带空格来间隔单词的语言，分词则不是什么问题，使用朴素贝叶斯方法将会更加顺畅。</p>
</blockquote>
<h2>14. 实际工程的tricks</h2>
<p>应用朴素贝叶斯方法的过程中，一些tricks能显著帮助工程解决问题。我们毕竟经验有限，无法将它们全都罗列出来，只能就所知的一点点经验与大家分享，欢迎批评指正。</p>
<h3>14.1 trick1：取对数</h3>
<p>我们提到用来识别垃圾邮件的方法是比较以下两个概率的大小（字母S表示“垃圾邮件”,字母H表示“正常邮件”）：</p>
<p>$$
C = P(“我”|S)P(“司”|S)P(“可”|S)P(“办理”|S)P(“正规发票”|S)
$$</p>
<p>$$
×P(“保真”|S)P(“增值税”|S)P(“发票”|S)P(“点数”|S)P(“优惠”|S)P(“垃圾邮件”)
$$</p>
<p>$$
\overline{C}=P(“我”|H)P(“司”|H)P(“可”|H)P(“办理”|H)P(“正规发票”|H)
$$</p>
<p>$$
×P(“保真”|H)P(“增值税”|H)P(“发票”|H)P(“点数”|H)P(“优惠”|H)P(“正常邮件”)
$$</p>
<p>但这里进行了<strong>很多乘法运算，计算的时间开销比较大</strong>。尤其是对于篇幅比较长的邮件，几万个数相乘起来还是非常花时间的。如果能把<strong>这些乘法变成加法则方便得多</strong>。刚好数学中的对数函数log就可以实现这样的功能。两边同时取对数（本文统一取底数为2），则上面的公式变为：</p>
<p>$$
log{C} = log{P(“我”|S)}+log{P(“司”|S)}+log{P(“可”|S)}+log{P(“办理”|S)}+log{P(“正规发票”|S)}
$$</p>
<p>$$
+log{P(“保真”|S)}+log{P(“增值税”|S)}+log{P(“发票”|S)}+log{P(“点数”|S)}+log{P(“优惠”|S)}+log{P(“垃圾邮件”)}
$$</p>
<p>$$
log{\overline{C}}=log{P(“我”|H)}+log{P(“司”|H)}+log{P(“可”|H)}+log{P(“办理”|H)}+log{P(“正规发票”|H)}
$$</p>
<p>$$
+log{P(“保真”|H)}+log{P(“增值税”|H)}+log{P(“发票”|H)}+log{P(“点数”|H)}+log{P(“优惠”|H)}+log{P(“正常邮件”)}
$$</p>
<p>有同学可能要叫了：“做对数运算岂不会也很花时间？”的确如此，但是可以在训练阶段直接计算  $logP$  ，然后把他们存在一张大的hash表里。<strong>在判断的时候直接提取hash表中已经计算好的对数概率，然后相加即可。这样使得判断所需要的计算时间被转移到了训练阶段</strong>，实时运行的时候速度就比之前快得多，这可不止几个数量级的提升。</p>
<h3>14.2 trick2：转换为权重</h3>
<p>对于二分类，我们还可以继续提高判断的速度。既然要比较 $log$ 和 $log{\overline{C}}$ 的大小，那就可以直接将上下两式相减，并继续化简：</p>
<p>$$
log{\frac{C}{\overline{C}}}=log{\frac{P(“我”|S)}{P(“我”|H)}}+log{\frac{P(“司”|S)}{P(“司”|H)}}+log{\frac{P(“可”|S)}{P(“可”|H)}}+log{\frac{P(“办理”|S)}{P(“办理”|H)}}+log{\frac{P(“正规发票”|S)}{P(“正规发票”|H)}}
$$</p>
<p>$$
+log{\frac{P(“保真”|S)}{P(“保真”|H)}}+log{\frac{P(“增值税”|S)}{P(“增值税”|H)}}+log{\frac{P(“发票”|S)}{P(“发票”|H)}}+log{\frac{P(“点数”|S)}{P(“点数”|H)}}+log{\frac{P(“优惠”|S)}{P(“优惠”|H)}}+log{\frac{P(“正常邮件”|S)}{P(“正常邮件”)}}
$$</p>
<p>$log{\frac{C}{\overline{C}}}$如果大于0则属于垃圾邮件。我们可以把其中每一项作为其对应词语的权重，比如 $log{\frac{P(“发票”|S)}{P(“发票”|H)}}$  就可以作为词语“发票”的权重，权重越大就越说明“发票”更可能是与“垃圾邮件”相关的特征。这样可以根据权重的大小来评估和筛选显著的特征，比如关键词。而这些权重值可以直接提前计算好而存在hash表中 。判断的时候直接将权重求和即可。</p>
<p>关键词hash表的样子如下，左列是权重，右列是其对应的词语，权重越高的说明越“关键”：</p>
<p><img src="/images/ml/bayes/bayes-04.jpg" alt=""></p>
<h3>14.3 trick3：选取topk的关键词</h3>
<p>前文说过可以通过提前选取关键词来提高判断的速度。有一种方法可以省略提前选取关键词的步骤，就是直接选取一段文本中权重最高的K个词语，将其权重进行加和。比如Paul Graham 在《黑客与画家》中是选取邮件中权重最高的15个词语计算的。</p>
<p>通过权重hash表可知，如果是所有词语的权重，则权重有正有负。如果只选择权重最高的 $K$ 个词语，则它们的权重基本都是正的。所以就不能像之前那样判断 $log{\frac{C}{\overline{C}}}$ 是否大于0来区分邮件了。而这需要依靠经验选定一个正数的阈值（门槛值） ，依据 $log{\frac{C}{\overline{C}}}$  与该门槛值的大小来识别垃圾邮件。</p>
<p>如下图所示，蓝色点代表垃圾邮件，绿色点代表正常邮件，横坐标为计算出来的 $log{\frac{C}{\overline{C}}}$  值，中间的红线代表阈值。</p>
<p>&lt;img src=&quot;/images/ml/bayes/bayes-07.jpg&quot; style=&quot;width:500px; height:250px;&quot;/&gt;</p>
<blockquote>
<p>k 的选取，需要你自己判断。可以通过交叉验证来判断。</p>
</blockquote>
<h3>14.4 trick4：分割样本</h3>
<p>选取topk个词语的方法对于篇幅变动不大的邮件样本比较有效。但是对篇幅过大或者过小的邮件则会有判断误差。</p>
<p>比如这个垃圾邮件的例子：（“我”,“司”,“可”,“办理”,“正规发票”,“保真”,“增值税”,“发票”,“点数”,“优惠”)。分词出了10个词语，其中有“正规发票”、“发票”2个关键词。关键词的密度还是蛮大的，应该算是敏感邮件。但因为采用最高15个词语的权重求和，并且相应的阈值是基于15个词的情况有效，可能算出来的结果还小于之前的阈值，这就造成漏判了。</p>
<p>类似的，如果一封税务主题的邮件有1000个词语，其中只有“正规发票”、“发票”、“避税方法”3个权重比较大的词语，它们只是在正文表述中顺带提到的内容。关键词的密度被较长的篇幅稀释了，应该算是正常邮件。但是却被阈值判断成敏感邮件，造成误判了。
这两种情况都说明topk关键词的方法需要考虑篇幅的影响。这里有许多种处理方式，它们的基本思想都是选取词语的个数及对应的阈值要与篇幅的大小成正比，本文只介绍其中一种方方法：</p>
<p>对于长篇幅邮件，按一定的大小，比如每500字，将其分割成小的文本段落，再对小文本段落采用topk关键词的方法。只要其中有一个小文本段落超过阈值就判断整封邮件是垃圾邮件。</p>
<p>对于超短篇幅邮件，比如50字，可以按篇幅与标准比较篇幅的比例来选取topk，以确定应该匹配关键词语的个数。比如选取  50500×15≈250500×15≈2  个词语进行匹配，相应的阈值可以是之前阈值的  215215  。以此来判断则更合理。</p>
<h3>14.5 trick5：位置权重</h3>
<h3>14.6 trick6：蜜罐</h3>
<p>我们通过辛辛苦苦的统计与计算，好不容易得到了不同词语的权重。然而这并不是一劳永逸的。我们我们之前交代过，词语及其权重会随着时间不断变化，需要时不时地用最新的样本来训练以更新词语及其权重。</p>
<p>而搜集最新垃圾邮件有一个技巧，就是随便注册一些邮箱，然后将它们公布在各大论坛上。接下来就坐等一个月，到时候收到的邮件就绝大部分都是垃圾邮件了（好奸诈）。再找一些正常的邮件，基本就能够训练了。这些用于自动搜集垃圾邮件的邮箱叫做“蜜罐”。“蜜罐”是网络安全领域常用的手段，因其原理类似诱捕昆虫的装有蜜的罐子而得名。比如杀毒软件公司会利用蜜罐来监视或获得计算机网络中的病毒样本、攻击行为等。</p>
<h2>15. 贝叶斯方法的思维方式</h2>
<h3>15.1 逆概问题</h3>
<p>$$
P(Y|X)=\frac{P(X|Y)P(Y)}{P(X)}
$$</p>
<p>先不考虑先验概率 $P(Y)$ 与 $P(X)$ ，观察两个后验概率 $P(Y|X)$ 与 $P(X|Y)$，可见贝叶斯公式能够揭示两个相反方向的条件概率之间的转换关系。</p>
<ul>
<li>
<p>从贝叶斯历史来看, 其就是为了处理所谓 “<code>逆概</code>” 问题而诞生的。比如 $P(Y|X)$  不能通过直接观测来得到结果，而 $P(X|Y)$ 却容易通过直接观测得到结果，就可以通过贝叶斯公式从间接地观测对象去推断不可直接观测的对象的情况。</p>
</li>
<li>
<p><code>人话版本</code>: 基于邮件的文本内容判断其属于垃圾邮件的概率不好求（不可通过直接观测、统计得到），但是基于已经搜集好的垃圾邮件样本，去统计（直接观测）其文本内部各个词语的概率却非常方便。这就可以用贝叶斯方法。</p>
</li>
<li>
<p>引申一步: 基于样本特征去判断其所属标签的概率不好求，但是基于已经搜集好的打上标签的样本（有监督），却可以直接统计属于同一标签的样本内部各个特征的概率分布。因此贝叶斯方法的理论视角适用于一切分类问题的求解。</p>
</li>
</ul>
<h3>15.2 多分类问题</h3>
<ol>
<li>垃圾邮件</li>
<li>私人邮件 (正常)</li>
<li>工作邮件 (正常)</li>
</ol>
<p>现在有这 3 类邮件各 1 万封作为样本。需要训练出一个贝叶斯分类器。这里依次用 $Y_1,Y_2,Y_3$ 表示这三类邮件，用 $X$ 表示被判断的邮件。套用贝叶斯公式有：</p>
<p>$$
P(Y_1|X)=\frac{P(X|Y_1)P(Y_1)}{P(X)}
$$</p>
<p>$$
P(Y_2|X)=\frac{P(X|Y_2)P(Y_2)}{P(X)}
$$</p>
<p>$$
P(Y_3|X)=\frac{P(X|Y_3)P(Y_3)}{P(X)}
$$</p>
<p>通过比较 <strong>3</strong> 个概率值的大小即可得到 $X$ 所属的分类。发现三个式子的分母 $P(X)$ 一样，比较大小时可以忽略不计，于是就可以用下面这一个式子表达上面 <strong>3</strong> 式：</p>
<p>$$
P(Y_i|X)\propto P(X|Y_i)P(Y_i)  ； i=1,2,3
$$</p>
<p>其中 $\propto$ 表示“正比于”。而 $P(X|Y_i)$ 则有个特别高逼格的名字叫做 “<strong>似然函数</strong>”。其实把它直接理解成“ $P(Yi|X)$ 的逆反条件概率” 就方便了。</p>
<blockquote>
<p>对于任意多分类的问题都可以用这样的思路去理解。比如 <strong>新闻分类、情感喜怒哀乐分类</strong> 等等。</p>
</blockquote>
<h3>15.3 先验概率的问题</h3>
<p>在垃圾邮件的例子中，先验概率都相等， $P(Y_1)=P(Y_2)=P(Y_3)=10000/30000=1/3$，所以上面是式子又可以进一步化简：</p>
<p>$$
P(Y_i|X)\propto P(X|Y_i)  ； i=1,2,3
$$</p>
<p>只需比较右边式子（也就是“似然函数”）的大小就可以了。这种方法就是传说中的<strong>最大似然法</strong>: 不考虑先验概率而直接比较似然函数。</p>
<p>关于选出最佳分类 $Y_i$ 是否要考虑先验概率 $P(Y_i)$ 的问题，曾经在频率学派和贝叶斯学派之间产生了激烈的教派冲突。统计学家（频率学派）说：我们让数据自己说话。言下之意就是要摒弃先验概率。而贝叶斯学派支持者则说：数据会有各种各样的偏差，而一个<strong>靠谱的先验概率</strong>则可以对这些随机噪音做到健壮.</p>
<p>比如我们在采集垃圾邮件样本的时候，不小心delete掉了一半的数据，就剩下5000封邮件。则计算出来的先验概率为:</p>
<p>$$
P(Y_1)=5000/25000=1/5
$$</p>
<p>$$
P(Y_2)=P(Y_3)=10000/25000=2/5
$$</p>
<p>如果还用贝叶斯方法,就要在似然函数后面乘上先验概率。比如之前用最大似然法算出 $Y_1$  垃圾邮件的概率大，但是因为 $P(Y_1)$ 特别小，用贝叶斯方法得出的结果是 $Y_2$  私人邮件的概率大。那相信哪个呢？其实，我们删掉了部分带标签的样本，从计算结果看 $P(Y1)$，$P(Y2)$，$P(Y3)$ 的概率分布变化了，但实际上<strong>这三个类别的真实分布应该是一个客观的状态，不应该因为我们的计算方法而发生变化</strong>。所以是我们计算出来的先验概率失真，应该放弃这样计算出来的先验概率，而用最大似然法。</p>
<p>但即便我们不删掉一半垃圾邮件，这三类邮件的分布就真的是 $1:1:1$ 那样平均吗？那也未必。<strong>我们只是按1:1:1这样的方式进行了抽样而已，真正在邮箱里收到的这三类邮件的分布可能并不是这样。也就是说，在我们对于先验概率一无所知时，只能假设每种猜测的先验概率是均等的（其实这也是人类经验的结果），这个时候就只有用最大似然了</strong>。在现实运用过程中如果发现最大似然法有偏差，可以考虑对不同的似然函数设定一些系数或者阈值，使其接近真实情况。</p>
<p>但是，<strong>如果我们有足够的自信，训练集中这三类的样本分布的确很接近真实的情况，这时就应该用贝叶斯方法</strong>。难怪前面的贝叶斯学派强调的是“靠谱的先验概率”。所以说<strong>贝叶斯学派的适用范围更广，关键要先验概率靠谱，而频率学派有效的前提也是他们的先验概率同样是经验统计的结果</strong>。</p>
<h2>16. (朴素)贝叶斯方法的常见应用</h2>
<p><strong>褒贬分析</strong></p>
<p>一个比较常见的应用场景是情感褒贬分析。比如你要统计微博上人们对一个新上映电影的褒贬程度评价：好片还是烂片。但是一条一条地看微博是根本看不过来，只能用自动化的方法。我们可以有一个很粗略的思路：</p>
<ul>
<li>首先是用爬虫将微博上提到这个电影名字的微博全都抓取下来，比如有10万条。</li>
<li>然后用训练好的朴素贝叶斯分类器分别判断这些微博对电影是好评还是差评。</li>
<li>最后统计出这些好评的影评占所有样本中的比例，就能形成微博网友对这个电影综合评价的大致估计。</li>
</ul>
<p>接下来的核心问题就是训练出一个靠谱的分类器。首先需要有打好标签的文本。这个好找，豆瓣影评上就有大量网友对之前电影的评价，并且对电影进行1星到5星的评价。我们可以认为3星以上的评论都是好评，3星以下的评论都是差评。这样就分别得到了好评差评两类的语料样本。剩下就可以用朴素贝叶斯方法进行训练了。基本思路如下：</p>
<ul>
<li>训练与测试样本：豆瓣影评的网友评论，用爬虫抓取下100万条。</li>
<li>标签：3星以上的是好评，3星以下的是差评。</li>
<li>特征：豆瓣评论分词后的词语。一个简单的方法是只选择其中的形容词，网上有大量的情绪词库可以为我们所用。</li>
<li>然后再用常规的朴素贝叶斯方法进行训练。</li>
</ul>
<p>但是由于自然语言的特点，在提取特征的过程当中，有一些tricks需要注意</p>
<ul>
<li>
<p><strong>对否定句进行特别的处理</strong>。比如这句话“我不是很喜欢部电影，因为它让我开心不起来。”其中两个形容词“喜欢”、“开心”都是褒义词，但是因为句子的否定句，所以整体是贬义的。有一种比较简单粗暴的处理方式，就是“对否定词（“不”、“非”、“没”等）与句尾标点之间的所有形容词都采用其否定形式” 。则这句话中提取出来的形容词就应该是“不喜欢”和“不开心”。</p>
</li>
<li>
<p>一般说来，<strong>最相关的情感词在一些文本片段中仅仅出现一次，词频模型起得作用有限</strong>，甚至是负作用，则使用<code>伯努利模型</code>代替多项式模型。这种情况在微博这样的小篇幅文本中似乎不太明显，但是在博客、空间、论坛之类允许长篇幅文本出现的平台中需要注意。</p>
</li>
<li>
<p>其实，副词对情感的评价有一定影响。“不很喜欢”与“很不喜欢”的程度就有很大差异。但如果是朴素贝叶斯方法的话比较难处理这样的情况。我们可以考虑用语言模型或者加入词性标注的信息进行综合判断。这些内容我们将在之后进行探讨。</p>
</li>
</ul>
<p>当然经过以上的处理，情感分析还是会有一部分误判。这里涉及到许多问题，都是情感分析的难点：</p>
<ul>
<li><strong>情绪表达的含蓄微妙</strong>：“导演你出来，我保证不打死你。”你让机器怎么判断是褒还是贬？</li>
<li><strong>转折性表达</strong>：“我非常喜欢这些大牌演员，非常崇拜这个导演，非常赞赏这个剧本，非常欣赏他们的预告片，我甚至为了这部影片整整期待了一年，最后进了电影院发现这是个噩梦。” 五个褒义的形容词、副词对一个不那么贬义的词。机器自然判断成褒义，但这句话是妥妥的贬义。</li>
</ul>
<h2>17. 内容小结</h2>
<p>从前面大家基本可以看出，工程应用不同于学术理论，有许多tricks需要考虑，而理论本质就是翻来倒去折腾贝叶斯公式，都快玩出花来了。</p>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-nlp/string-operation-re" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/07/30/nlp/string-operation-re/"><strong>Python 字符串处理-正则表达式</strong></a>
      <small class=article-date-index>&nbsp; 2017-07-30</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/07/30/nlp/string-operation-re/" class="article-date">
  <time datetime="2017-07-30T10:08:21.000Z" itemprop="datePublished">2017-07-30</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/nlp/">nlp</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/07/30/nlp/string-operation-re/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>Python 字符串处理 之 正则表达式 <a href="https://github.com/blair101/machine-learning-action/tree/master/string_operation" target="_blank" rel="noopener">Github-ipynb</a></p>
<h3>字符串操作</h3>
<p>我们一起回归一下python字符串的相关操作，这是非常基础的知识，但却是使用频度非常高的一些功能。</p>
<p>&lt;!-- more --&gt;</p>
<h4>1.1 去空格及特殊符号</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">' hello, world!'</span></span><br><span class="line"><span class="keyword">print</span> s.strip()</span><br><span class="line"><span class="keyword">print</span> s.lstrip(<span class="string">' hello, '</span>)</span><br><span class="line"><span class="keyword">print</span> s.rstrip(<span class="string">'!'</span>)</span><br></pre></td></tr></table></figure></p>
<pre><code>hello, world!
world!
 hello, world
</code></pre>
<h4>1.2 连接字符串</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sStr1 = <span class="string">'strcat'</span></span><br><span class="line">sStr2 = <span class="string">'append'</span></span><br><span class="line">sStr1 += sStr2</span><br><span class="line"><span class="keyword">print</span> sStr1</span><br></pre></td></tr></table></figure></p>
<pre><code>strcatappend
</code></pre>
<h4>1.3 查找字符</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &lt; 0 为未找到</span></span><br><span class="line">sStr1 = <span class="string">'strchr'</span></span><br><span class="line">sStr2 = <span class="string">'r'</span></span><br><span class="line">nPos = sStr1.index(sStr2)</span><br><span class="line"><span class="keyword">print</span> nPos</span><br></pre></td></tr></table></figure></p>
<pre><code>2
</code></pre>
<h4>1.4 较字符串</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sStr1 = <span class="string">'strchr'</span></span><br><span class="line">sStr2 = <span class="string">'strch'</span></span><br><span class="line"><span class="keyword">print</span> cmp(sStr2,sStr1)</span><br><span class="line"><span class="keyword">print</span> cmp(sStr1,sStr2)</span><br><span class="line"><span class="keyword">print</span> cmp(sStr1,sStr1)</span><br></pre></td></tr></table></figure></p>
<pre><code>-1
1
0
</code></pre>
<h4>1.5 大小写转换</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sStr1 = <span class="string">'JCstrlwr'</span></span><br><span class="line">sStr1 = sStr1.upper()</span><br><span class="line"><span class="comment">#sStr1 = sStr1.lower()</span></span><br><span class="line"><span class="keyword">print</span> sStr1</span><br></pre></td></tr></table></figure></p>
<pre><code>JCSTRLWR
</code></pre>
<h4>1.6 翻转字符串</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sStr1 = <span class="string">'abcdefg'</span></span><br><span class="line">sStr1 = sStr1[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">print</span> sStr1</span><br></pre></td></tr></table></figure></p>
<pre><code>gfedcba
</code></pre>
<h4>1.7 查找字符串</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sStr1 = <span class="string">'abcdefg'</span></span><br><span class="line">sStr2 = <span class="string">'cde'</span></span><br><span class="line"><span class="keyword">print</span> sStr1.find(sStr2)</span><br></pre></td></tr></table></figure></p>
<pre><code>2
</code></pre>
<h4>1.8 分割字符串</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sStr1 = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">sStr2 = <span class="string">','</span></span><br><span class="line">sStr1 = sStr1[sStr1.find(sStr2) + <span class="number">1</span>:]</span><br><span class="line"><span class="keyword">print</span> sStr1</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">s = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">print(s.split(<span class="string">','</span>))</span><br></pre></td></tr></table></figure></p>
<pre><code>cde,fgh,ijk
['ab', 'cde', 'fgh', 'ijk']
</code></pre>
<h4>1.9 频次最高的字母</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#version 1</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_max_value_v1</span><span class="params">(text)</span>:</span></span><br><span class="line">    text = text.lower()</span><br><span class="line">    result = re.findall(<span class="string">'[a-zA-Z]'</span>, text)  <span class="comment"># 去掉列表中的符号符</span></span><br><span class="line">    count = Counter(result)  <span class="comment"># Counter(&#123;'l': 3, 'o': 2, 'd': 1, 'h': 1, 'r': 1, 'e': 1, 'w': 1&#125;)</span></span><br><span class="line">    count_list = list(count.values())</span><br><span class="line">    max_value = max(count_list)</span><br><span class="line">    max_list = []</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> count.items():</span><br><span class="line">        <span class="keyword">if</span> v == max_value:</span><br><span class="line">            max_list.append(k)</span><br><span class="line">    max_list = sorted(max_list)</span><br><span class="line">    <span class="keyword">return</span> max_list[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#version 2</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_max_value</span><span class="params">(text)</span>:</span></span><br><span class="line">    count = Counter([x <span class="keyword">for</span> x <span class="keyword">in</span> text.lower() <span class="keyword">if</span> x.isalpha()])</span><br><span class="line">    m = max(count.values())</span><br><span class="line">    <span class="keyword">return</span> sorted([x <span class="keyword">for</span> (x, y) <span class="keyword">in</span> count.items() <span class="keyword">if</span> y == m])[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#version 3</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_max_value</span><span class="params">(text)</span>:</span></span><br><span class="line">    text = text.lower()</span><br><span class="line">    <span class="keyword">return</span> max(string.ascii_lowercase, key=text.count)</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max(range(<span class="number">6</span>), key = <span class="keyword">lambda</span> x : x&gt;<span class="number">2</span>)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 3</span></span><br><span class="line"><span class="comment"># 带入key函数中，各个元素返回布尔值，相当于[False, False, False, True, True, True]</span></span><br><span class="line"><span class="comment"># key函数要求返回值为True，有多个符合的值，则挑选第一个。</span></span><br><span class="line"></span><br><span class="line">max([<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>], key = <span class="keyword">lambda</span> x : x)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 5</span></span><br><span class="line"><span class="comment"># 带入key函数中，各个元素返回自身的值，最大的值为5，返回5.</span></span><br><span class="line"></span><br><span class="line">max(<span class="string">'ah'</span>, <span class="string">'bf'</span>, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 'ah'</span></span><br><span class="line"><span class="comment"># 带入key函数，各个字符串返回最后一个字符，其中'ah'的h要大于'bf'中的f，因此返回'ah'</span></span><br><span class="line"></span><br><span class="line">max(<span class="string">'ah'</span>, <span class="string">'bf'</span>, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 'bf'</span></span><br><span class="line"><span class="comment"># 带入key函数，各个字符串返回第一个字符，其中'bf'的b要大于'ah'中的a，因此返回'bf'</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">'Hello World'</span></span><br><span class="line">max(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>, key=text.count)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 'l'</span></span><br><span class="line"><span class="comment"># 带入key函数，返回各个字符在'Hello World'中出现的次数，出现次数最多的字符为'l',因此输出'l'</span></span><br></pre></td></tr></table></figure></p>
<pre><code>'l'
</code></pre>
<h4>Count occurrence of a character in a Python string</h4>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#T  h  e     M  i  s  s  i  s  s  i  p  p  i     R  i  v  e  r</span></span><br><span class="line"><span class="comment">#[1, 1, 2, 2, 1, 5, 4, 4, 5, 4, 4, 5, 2, 2, 5, 2, 1, 5, 1, 2, 1]</span></span><br><span class="line">sentence=<span class="string">'The Mississippi River'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_chars</span><span class="params">(s)</span>:</span></span><br><span class="line">        s=s.lower()</span><br><span class="line">        count=list(map(s.count,s))</span><br><span class="line">        <span class="keyword">return</span> (max(count))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> count_chars(sentence)</span><br></pre></td></tr></table></figure></p>
<pre><code>5
</code></pre>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-nlp/jieba" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/07/29/nlp/jieba/"><strong>Jieba 中文处理</strong></a>
      <small class=article-date-index>&nbsp; 2017-07-29</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/07/29/nlp/jieba/" class="article-date">
  <time datetime="2017-07-29T10:08:21.000Z" itemprop="datePublished">2017-07-29</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/nlp/">nlp</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/07/29/nlp/jieba/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>NLP 基础技能 ： Jieba 中文分词与处理</p>
<p><a href="https://github.com/blair101/machine-learning-action/blob/master/string_operation/jieba-learning-Notes.ipynb" target="_blank" rel="noopener">Github-ipynb</a></p>
<p>&lt;!-- more --&gt;</p>
<p>词汇是我们对句子和文章理解的基础，因此需要一个工具去把完整的文本中分解成粒度更细的词</p>
<p><strong>jieba</strong> 就是这样一个非常好用的中文工具，是以分词起家的，但是功能比分词要强大很多。</p>
<h2>1. 基本分词函数与用法</h2>
<ol>
<li>jieba.cut</li>
<li>jieba.cut_for_search</li>
</ol>
<p>返回的结构都是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语(unicode)</p>
<p><strong>jieba.cut</strong> 方法接受三个输入参数:</p>
<ul>
<li>需要分词的字符串</li>
<li>cut_all 参数用来控制是否采用全模式</li>
<li>HMM 参数用来控制是否使用 HMM 模型</li>
</ul>
<p><strong>jieba.cut_for_search</strong> 方法接受两个参数</p>
<ul>
<li>需要分词的字符串</li>
<li>是否使用 HMM 模型。</li>
</ul>
<p>该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(<span class="string">"我在学习自然语言处理"</span>, cut_all=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> seg_list</span><br><span class="line">print(<span class="string">"Full Mode: "</span> + <span class="string">"/ "</span>.join(seg_list))  <span class="comment"># 全模式</span></span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(<span class="string">"我在学习自然语言处理"</span>, cut_all=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">"Default Mode: "</span> + <span class="string">"/ "</span>.join(seg_list))  <span class="comment"># 精确模式</span></span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(<span class="string">"他毕业于上海交通大学，在百度深度学习研究院进行研究"</span>)  <span class="comment"># 默认是精确模式</span></span><br><span class="line">print(<span class="string">", "</span>.join(seg_list))</span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut_for_search(<span class="string">"小明硕士毕业于中国科学院计算所，后在哈佛大学深造"</span>)  <span class="comment"># 搜索引擎模式</span></span><br><span class="line">print(<span class="string">", "</span>.join(seg_list))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Building prefix dict from the default dictionary ...</span><br><span class="line">&lt;generator object cut at 0x110370460&gt;</span><br><span class="line">Dumping model to file cache /var/folders/mf/_jgd83rx0rgcmt42cp7fkkd00000gn/T/jieba.cache</span><br><span class="line">Loading model cost 2.184 seconds.</span><br><span class="line">Prefix dict has been built succesfully.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Full Mode: 我/ 在/ 学习/ 自然/ 自然语言/ 语言/ 处理</span><br><span class="line">Default Mode: 我/ 在/ 学习/ 自然语言/ 处理</span><br><span class="line">他, 毕业, 于, 上海交通大学, ，, 在, 百度, 深度, 学习, 研究院, 进行, 研究</span><br><span class="line">小明, 硕士, 毕业, 于, 中国, 科学, 学院, 科学院, 中国科学院, 计算, 计算所, ，, 后, 在, 哈佛, 大学, 哈佛大学, 深造</span><br></pre></td></tr></table></figure></p>
<p><strong>jieba.lcut</strong> 以及 <strong>jieba.lcut_for_search</strong> 直接返回 list</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result_lcut = jieba.lcut(<span class="string">"小明硕士毕业于中国科学院计算所，后在哈佛大学深造"</span>)</span><br><span class="line"><span class="keyword">print</span> result_lcut</span><br><span class="line"><span class="keyword">print</span> <span class="string">" "</span>.join(result_lcut)</span><br><span class="line"><span class="keyword">print</span> <span class="string">" "</span>.join(jieba.lcut_for_search(<span class="string">"小明硕士毕业于中国科学院计算所，后在哈佛大学深造"</span>))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[u&apos;\u5c0f\u660e&apos;, u&apos;\u7855\u58eb&apos;, u&apos;\u6bd5\u4e1a&apos;, u&apos;\u4e8e&apos;, u&apos;\u4e2d\u56fd\u79d1\u5b66\u9662&apos;, u&apos;\u8ba1\u7b97\u6240&apos;, u&apos;\uff0c&apos;, u&apos;\u540e&apos;, u&apos;\u5728&apos;, u&apos;\u54c8\u4f5b\u5927\u5b66&apos;, u&apos;\u6df1\u9020&apos;]</span><br><span class="line">小明 硕士 毕业 于 中国科学院 计算所 ， 后 在 哈佛大学 深造</span><br><span class="line">小明 硕士 毕业 于 中国 科学 学院 科学院 中国科学院 计算 计算所 ， 后 在 哈佛 大学 哈佛大学 深造</span><br></pre></td></tr></table></figure></p>
<h3>1.1 添加用户自定义词典</h3>
<p>很多时候我们需要针对自己的场景进行分词，会有一些领域内的专有词汇。</p>
<ol>
<li>可以用 <code>jieba.load_userdict(file_name)</code> 加载用户字典</li>
<li>少量的词汇可以自己用下面方法手动添加：</li>
</ol>
<p>用 <strong>add_word(word, freq=None, tag=None)</strong> 和 <strong>del_word(word)</strong> 在程序中动态修改词典<br>
用 <strong>suggest_freq(segment, tune=True)</strong> 可调节单个词语的词频，使其能（或不能）被分出来。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'如果放到旧字典中将出错。'</span>, HMM=<span class="literal">False</span>)))</span><br><span class="line"><span class="keyword">print</span> jieba.suggest_freq((<span class="string">'中'</span>, <span class="string">'将'</span>), <span class="literal">True</span>)</span><br><span class="line">print(<span class="string">'/'</span>.join(jieba.cut(<span class="string">'如果放到旧字典中将出错。'</span>, HMM=<span class="literal">False</span>)))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果/放到/旧/字典/中将/出错/。</span><br><span class="line">494</span><br><span class="line">如果/放到/旧/字典/中/将/出错/。</span><br></pre></td></tr></table></figure></p>
<h2>2. 关键词提取</h2>
<h3>2.1 TF-IDF 算法的关键词抽取</h3>
<p>import jieba.analyse<br>
jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=())</p>
<ul>
<li>sentence 为待提取的文本</li>
<li>topK 为返回几个 TF/IDF 权重最大的关键词，默认值为 20</li>
<li>withWeight 为是否一并返回关键词权重值，默认值为 False</li>
<li>allowPOS 仅包括指定词性的词，默认值为空，即不筛选</li>
</ul>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse <span class="keyword">as</span> analyse</span><br><span class="line">lines = open(<span class="string">'NBA.txt'</span>).read()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"  "</span>.join(analyse.extract_tags(lines, topK=<span class="number">20</span>, withWeight=<span class="literal">False</span>, allowPOS=()))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">韦少  杜兰特  全明星  全明星赛  MVP  威少  正赛  科尔  投篮  勇士  球员  </span><br><span class="line">斯布鲁克  更衣柜  张卫平  三连庄  NBA  西部  指导  雷霆  明星队</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = open(<span class="string">u'西游记.txt'</span>).read()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"  "</span>.join(analyse.extract_tags(lines, topK=<span class="number">20</span>, withWeight=<span class="literal">False</span>, allowPOS=()))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行者  八戒  师父  三藏  唐僧  大圣  沙僧  妖精  菩萨  和尚  那怪  那里  </span><br><span class="line">长老  呆子  徒弟  怎么  不知  老孙  国王  一个</span><br></pre></td></tr></table></figure></p>
<h3>2.2 TF-IDF 关键词抽取补充</h3>
<p>关键词提取所使用逆向文件频率（<strong>IDF</strong>）文本语料库可以切换成自定义语料库的路径</p>
<ul>
<li>用法： jieba.analyse.set_idf_path(file_name) # file_name为自定义语料库的路径</li>
<li>自定义语料库示例见<a href="https://github.com/fxsjy/jieba/blob/master/extra_dict/idf.txt.big" target="_blank" rel="noopener">这里</a></li>
<li>用法示例见<a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_idfpath.py" target="_blank" rel="noopener">这里</a></li>
</ul>
<p>关键词提取所使用停止词（<strong>Stop Words</strong>）文本语料库可以切换成自定义语料库的路径</p>
<ul>
<li>用法： jieba.analyse.set_stop_words(file_name) # file_name为自定义语料库的路径</li>
<li>自定义语料库示例见<a href="https://github.com/fxsjy/jieba/blob/master/extra_dict/stop_words.txt" target="_blank" rel="noopener">这里</a></li>
<li>用法示例见<a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_stop_words.py" target="_blank" rel="noopener">这里</a></li>
</ul>
<p>关键词一并返回关键词权重值示例</p>
<ul>
<li>用法示例见<a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_with_weight.py" target="_blank" rel="noopener">这里</a></li>
</ul>
<h3>2.3 TextRank 的关键词抽取</h3>
<ul>
<li>jieba.analyse.textrank(sentence, topK=20, withWeight=False, allowPOS=('ns', 'n', 'vn', 'v')) 直接使用，接口相同，注意默认过滤词性。</li>
<li>jieba.analyse.TextRank() 新建自定义 TextRank 实例</li>
</ul>
<p>算法论文： TextRank: <a href="http://web.eecs.umich.edu/~mihalcea/papers/mihalcea.emnlp04.pdf" target="_blank" rel="noopener">Bringing Order into Texts</a></p>
<p>基本思想:</p>
<ul>
<li>将待抽取关键词的文本进行分词</li>
<li>以固定窗口大小(默认为5，通过span属性调整)，词之间的共现关系，构建图</li>
<li>计算图中节点的PageRank，注意是无向带权图</li>
</ul>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse <span class="keyword">as</span> analyse</span><br><span class="line">lines = open(<span class="string">'NBA.txt'</span>).read()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"  "</span>.join(analyse.textrank(lines, topK=<span class="number">20</span>, withWeight=<span class="literal">False</span>, allowPOS=(<span class="string">'ns'</span>, <span class="string">'n'</span>, <span class="string">'vn'</span>, <span class="string">'v'</span>)))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"---------------------我是分割线----------------"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"  "</span>.join(analyse.textrank(lines, topK=<span class="number">20</span>, withWeight=<span class="literal">False</span>, allowPOS=(<span class="string">'ns'</span>, <span class="string">'n'</span>)))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Building prefix dict from the default dictionary ...</span><br><span class="line">Loading model from cache /var/folders/mf/_jgd83rx0rgcmt42cp7fkkd00000gn/T/jieba.cache</span><br><span class="line">Loading model cost 0.530 seconds.</span><br><span class="line">Prefix dict has been built succesfully.</span><br><span class="line"></span><br><span class="line">全明星赛  勇士  正赛  指导  对方  投篮  球员  没有  出现  时间  威少  </span><br><span class="line">认为  看来  结果  相隔  助攻  现场  三连庄  介绍  嘉宾</span><br><span class="line">---------------------我是分割线----------------</span><br><span class="line">勇士  正赛  全明星赛  指导  投篮  玩命  时间  对方  现场  结果  球员  </span><br><span class="line">嘉宾  时候  全队  主持人  特点  大伙  肥皂剧  全程  快船队</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = open(<span class="string">u'西游记.txt'</span>).read()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"  "</span>.join(analyse.textrank(lines, topK=<span class="number">20</span>, withWeight=<span class="literal">False</span>, allowPOS=(<span class="string">'ns'</span>, <span class="string">'n'</span>, <span class="string">'vn'</span>, <span class="string">'v'</span>)))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行者  师父  八戒  三藏  大圣  不知  菩萨  妖精  只见  长老  国王  却说  </span><br><span class="line">呆子  徒弟  小妖  出来  不得  不见  不能  师徒</span><br></pre></td></tr></table></figure></p>
<h2>3. 词性标注</h2>
<ul>
<li>jieba.posseg.POSTokenizer(tokenizer=None) 新建自定义分词器，tokenizer 参数可指定内部使用的 jieba.Tokenizer 分词器。</li>
<li>jieba.posseg.dt 为默认词性标注分词器。</li>
<li>标注句子分词后每个词的词性，采用和 ictclas 兼容的标记法。</li>
<li>具体的词性对照表参见计算所汉语词性标记集 <a href="http://ictclas.nlpir.org/nlpir/html/readme.htm" target="_blank" rel="noopener">计算所汉语词性标记集</a></li>
</ul>
<p><a href="http://ictclas.nlpir.org/" target="_blank" rel="noopener">ictclas</a></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg</span><br><span class="line">words = pseg.cut(<span class="string">"我爱自然语言处理"</span>)</span><br><span class="line"><span class="keyword">for</span> word, flag <span class="keyword">in</span> words:</span><br><span class="line">    print(<span class="string">'%s %s'</span> % (word, flag))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我 r</span><br><span class="line">爱 v</span><br><span class="line">自然语言 l</span><br><span class="line">处理 v</span><br></pre></td></tr></table></figure></p>
<h2>4. 并行分词</h2>
<p>原理：将目标文本按行分隔后，把各行文本分配到多个 Python 进程并行分词，然后归并结果，从而获得分词速度的可观提升 基于 python 自带的 multiprocessing 模块，目前暂不支持 Windows</p>
<p>用法：</p>
<ul>
<li>jieba.enable_parallel(4) # 开启并行分词模式，参数为并行进程数</li>
<li>jieba.disable_parallel() # 关闭并行分词模式</li>
</ul>
<p>实验结果：在 4 核 3.4GHz Linux 机器上，对金庸全集进行精确分词，获得了 1MB/s 的速度，是单进程版的 3.3 倍。</p>
<p>注意：并行分词仅支持默认分词器 jieba.dt 和 jieba.posseg.dt。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">jieba.enable_parallel()</span><br><span class="line">content = open(<span class="string">u'西游记.txt'</span>,<span class="string">"r"</span>).read()</span><br><span class="line">t1 = time.time()</span><br><span class="line">words = <span class="string">"/ "</span>.join(jieba.cut(content))</span><br><span class="line">t2 = time.time()</span><br><span class="line">tm_cost = t2-t1</span><br><span class="line">print(<span class="string">'并行分词速度为 %s bytes/second'</span> % (len(content)/tm_cost))</span><br><span class="line"></span><br><span class="line">jieba.disable_parallel()</span><br><span class="line">content = open(<span class="string">u'西游记.txt'</span>,<span class="string">"r"</span>).read()</span><br><span class="line">t1 = time.time()</span><br><span class="line">words = <span class="string">"/ "</span>.join(jieba.cut(content))</span><br><span class="line">t2 = time.time()</span><br><span class="line">tm_cost = t2-t1</span><br><span class="line">print(<span class="string">'非并行分词速度为 %s bytes/second'</span> % (len(content)/tm_cost))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">并行分词速度为 415863.760491 bytes/second</span><br><span class="line">非并行分词速度为 242471.700496 bytes/second</span><br></pre></td></tr></table></figure></p>
<h3>命令行分词</h3>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用示例：python -m jieba news.txt &gt; cut_result.txt</span><br><span class="line">命令行选项（翻译）：</span><br><span class="line">使用: python -m jieba [options] filename</span><br><span class="line"></span><br><span class="line">结巴命令行界面。</span><br><span class="line"></span><br><span class="line">固定参数:</span><br><span class="line">  filename              输入文件</span><br><span class="line"></span><br><span class="line">可选参数:</span><br><span class="line">  -h, --help            显示此帮助信息并退出</span><br><span class="line">  -d [DELIM], --delimiter [DELIM]</span><br><span class="line">                        使用 DELIM 分隔词语，而不是用默认的&apos; / &apos;。</span><br><span class="line">                        若不指定 DELIM，则使用一个空格分隔。</span><br><span class="line">  -p [DELIM], --pos [DELIM]</span><br><span class="line">                        启用词性标注；如果指定 DELIM，词语和词性之间</span><br><span class="line">                        用它分隔，否则用 _ 分隔</span><br><span class="line">  -D DICT, --dict DICT  使用 DICT 代替默认词典</span><br><span class="line">  -u USER_DICT, --user-dict USER_DICT</span><br><span class="line">                        使用 USER_DICT 作为附加词典，与默认词典或自定义词典配合使用</span><br><span class="line">  -a, --cut-all         全模式分词（不支持词性标注）</span><br><span class="line">  -n, --no-hmm          不使用隐含马尔可夫模型</span><br><span class="line">  -q, --quiet           不输出载入信息到 STDERR</span><br><span class="line">  -V, --version         显示版本信息并退出</span><br><span class="line"></span><br><span class="line">如果没有指定文件名，则使用标准输入。</span><br></pre></td></tr></table></figure></p>
<h3>Tokenize：返回词语在原文的起止位置</h3>
<p>注意，输入参数只接受 unicode</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">"这是默认模式的tokenize"</span></span><br><span class="line">result = jieba.tokenize(<span class="string">u'自然语言处理非常有用'</span>)</span><br><span class="line"><span class="keyword">for</span> tk <span class="keyword">in</span> result:</span><br><span class="line">    print(<span class="string">"%s\t\t start: %d \t\t end:%d"</span> % (tk[<span class="number">0</span>],tk[<span class="number">1</span>],tk[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n-----------我是神奇的分割线------------\n"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"这是搜索模式的tokenize"</span></span><br><span class="line">result = jieba.tokenize(<span class="string">u'自然语言处理非常有用'</span>, mode=<span class="string">'search'</span>)</span><br><span class="line"><span class="keyword">for</span> tk <span class="keyword">in</span> result:</span><br><span class="line">    print(<span class="string">"%s\t\t start: %d \t\t end:%d"</span> % (tk[<span class="number">0</span>],tk[<span class="number">1</span>],tk[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是默认模式的tokenize</span><br><span class="line">自然语言		 start: 0 		 end:4</span><br><span class="line">处理		 start: 4 		 end:6</span><br><span class="line">非常		 start: 6 		 end:8</span><br><span class="line">有用		 start: 8 		 end:10</span><br><span class="line">    </span><br><span class="line">-----------我是神奇的分割线------------</span><br><span class="line">    </span><br><span class="line">这是搜索模式的tokenize</span><br><span class="line">自然		 start: 0 		 end:2</span><br><span class="line">语言		 start: 2 		 end:4</span><br><span class="line">自然语言		 start: 0 		 end:4</span><br><span class="line">处理		 start: 4 		 end:6</span><br><span class="line">非常		 start: 6 		 end:8</span><br><span class="line">有用		 start: 8 		 end:10</span><br></pre></td></tr></table></figure></p>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-nlp/word2vector-basic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/07/12/nlp/word2vector-basic/"><strong>Word2vec 基础</strong></a>
      <small class=article-date-index>&nbsp; 2017-07-12</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/07/12/nlp/word2vector-basic/" class="article-date">
  <time datetime="2017-07-12T13:08:21.000Z" itemprop="datePublished">2017-07-12</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/nlp/">nlp</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/07/12/nlp/word2vector-basic/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>Natural Language Processing，计算机科学与语言学中关注于计算机与人类语言间转换的领域</p>
<p>&lt;!-- more --&gt;</p>
<h2>1. NLP 常见任务</h2>
<ol>
<li>自动摘要</li>
<li>指代消解</li>
<li>机器翻译</li>
<li>词性标注</li>
<li>分词 (中文、日文等)</li>
<li>主题识别</li>
<li>文本分类.<br>
......</li>
</ol>
<blockquote>
<p>自动摘要   -&gt;   搜索要索引，关键词等<br>
指代消解   -&gt;   小明放学了, 妈妈去接<code>他</code><br>
机器翻译   -&gt;   小心地滑、干货 =&gt; Slide carefully<br>
词性标注   -&gt;   heat(v.) water(n.) in(p.) a(det.)   pot(n.)<br>
分词 (中文、日文等)   -&gt;   大水沟/很/难/过</p>
</blockquote>
<h2>2. NLP 处理方法</h2>
<h3>2.1 传统: 基于规则</h3>
<p>Dict...</p>
<blockquote>
<p>简单、粗暴、有用</p>
</blockquote>
<h3>2.2 现代: 基于机器学习</h3>
<blockquote>
<p>HMM, CRF, SVM, LDA, CNN...<br>
“规则”隐含在模型参数里</p>
</blockquote>
<h2>3. 词编码和词向量初步</h2>
<blockquote>
<p>你需要一些 model，不管你是基于规则统计、机器学习、深度学习 的一些方法，第一步要做的，一定是对你的文本或者数据，进行表达, 词编码。</p>
</blockquote>
<p>&lt;font color=black&gt;『词编码需要保证词的相似性』&lt;font&gt;</p>
<p>Glove results</p>
<p>Nearest words to</p>
<ol>
<li>frog</li>
<li>toad</li>
<li>rana</li>
<li>...</li>
</ol>
<p>&lt;font color=black&gt;『向量空间分布的相似性』&lt;font&gt;</p>
<p><img src="/images/word2vector-2.png" alt=""></p>
<p>&lt;font color=black&gt;『向量空间子结构』&lt;font&gt;</p>
<blockquote>
<p>编码要尽量保证，相似的词的空间距离是相近的</p>
</blockquote>
<p>$V_{King}$ - $V_{Queen}$ + $V_{Women}$ = $V_{Man}$</p>
<p>$V_{Paris}$ - $V_{France}$ + $V_{German}$ = $V_{Berlin}$</p>
<blockquote>
<p>最终目标: 词向量表示作为机器学习、特别是深度学习的输入和表示空间</p>
</blockquote>
<hr>
<blockquote>
<p>你的 <code>数据</code> 决定了你的 <code>结果上限</code>
你的 <code>算法</code> 只是以多大程度去 <code>逼近</code></p>
</blockquote>
<hr>
<p><strong>Linguists</strong></p>
<p>&lt;img src=&quot;/images/nlp/word2vector-3.png&quot; width=&quot;520&quot; height=&quot;400&quot; align=&quot;middle&quot; /img&gt;</p>
<h3>3.1 离散表示 One-hot</h3>
<ul>
<li>&lt;font color=blue&gt;语料库&lt;font&gt;</li>
</ul>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John likes to watch movies. Mary likes too.John also likes to watch football games.</span><br></pre></td></tr></table></figure></p>
<ul>
<li>&lt;font color=blue&gt;词典&lt;font&gt;</li>
</ul>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"John"</span>: <span class="number">1</span>, <span class="string">"likes"</span>: <span class="number">2</span>, <span class="string">"to"</span>: <span class="number">3</span>, <span class="string">"watch"</span>: <span class="number">4</span>, <span class="string">"movies"</span>: <span class="number">5</span>, </span><br><span class="line"><span class="string">"also"</span>: <span class="number">6</span>, <span class="string">"football"</span>: <span class="number">7</span>, <span class="string">"games"</span>: <span class="number">8</span>, <span class="string">"Mary"</span>: <span class="number">9</span>, <span class="string">"too"</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>&lt;font color=blue&gt;One-hot表示&lt;font&gt;</li>
</ul>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]likes: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">...</span><br><span class="line">too : [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h3>3.2 离散表示 Bag of Words</h3>
<blockquote>
<p>文档的向量表示可以直接将各词的词向量表示加和</p>
</blockquote>
<p>John likes to watch movies. Mary likes too. =&gt; [1, 2, 1, 1, 1, 0, 0, 0, 1, 1]
John also likes to watch football games. =&gt; [1, 1, 1, 1, 0, 1, 1, 1, 0, 0]&gt; 词权重  - (<code>词在文档中的顺序没有被考虑</code>)</p>
<blockquote>
<p>tf-idf是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度
- TF-IDF (Term Frequency - Inverse Document Frequency)</p>
</blockquote>
<p>Term Frequency : F(term) = (该word词出现在当前文档中的次数) / (当前文档所有word的总数).</p>
<p>信息检索词 t 的 IDF</p>
<p>$$\log (1 + {\frac{N}{n^t}})$$</p>
<blockquote>
<p>N: 文档总数， n: 含有词 t 的文档数</p>
</blockquote>
<p>[0.693, 1.386, 0.693, 0.693, 1.099, 0, 0, 0, 0.693, 0.693]</p>
<p>Binary weighting</p>
<blockquote>
<p>不做计数的版本</p>
</blockquote>
<blockquote>
<p>短文本相似性, Bernoulli Naive Bayes [1, 1, 1, 1, 1, 0, 0, 0, 1, 1]</p>
</blockquote>
<blockquote>
<p>if so, I love you = you love I</p>
</blockquote>
<h3>3.3 离散表示 􏰜􏰝􏰞􏰟􏰒Bi-gram / 􏰪N-gram</h3>
<p>John likes to watch movies. Mary likes too.
John also likes to watch football games.</p>
<p>&lt;img src=&quot;/images/nlp/word2vector-4.png&quot; width=&quot;620&quot; height=&quot;400&quot; align=&quot;middle&quot; /img&gt;</p>
<h3>3.4 语言模型 词组合出现的概率</h3>
<p>一句话(词组合)出现的概率</p>
<p>&lt;img src=&quot;/images/nlp/word2vector-5.png&quot; width=&quot;620&quot; height=&quot;400&quot; align=&quot;middle&quot; /img&gt;</p>
<blockquote>
<p>简化计算 : $P(too | Mark, likes) \approx P(too | likes)$, 可参见 吴军 《数学之美》 解释</p>
</blockquote>
<h3>3.5 离散表示 的缺点</h3>
<p>&lt;img src=&quot;/images/nlp/word2vector-6.png&quot; width=&quot;620&quot; height=&quot;400&quot; align=&quot;middle&quot; /img&gt;</p>
<h3>3.6 分布式表示 提出</h3>
<p>&lt;img src=&quot;/images/nlp/word2vector-7.png&quot; width=&quot;620&quot; height=&quot;400&quot; align=&quot;middle&quot; /img&gt;</p>
<blockquote>
<p>Distributed representation :</p>
<p>用一个词附近的其他词来表示该词  - (不知道你的经济情况，就调查下你的狐朋狗友们)
􏰐􏱏􏲎􏰀􏳎􏳏􏰢􏳐􏳑􏰀􏳒􏰞You shall know a word by the company it keeps
--- J.R. Firth 1957
􏰐􏱏􏲎􏰀􏳎􏳏􏰢􏳐􏳑􏰀􏳒􏰞􏰟􏳓􏰀􏰑􏰐􏱏􏲎􏰀􏳎􏳏􏰢􏳐􏳑􏰀􏳒􏰞􏰟􏳓􏰀􏰑􏰐􏱏􏲎􏰀􏳎􏳏􏰢􏳐􏳑
􏱕􏳔􏳕􏳖􏳗&gt; 现代统计自然语言处理中最有创见的想法之一</p>
</blockquote>
<h2>4. 共现矩阵 (Cocurrence matrix)</h2>
<p>&lt;img src=&quot;/images/nlp/word2vector-8.png&quot; width=&quot;620&quot; height=&quot;400&quot; align=&quot;middle&quot; /img&gt;</p>
<blockquote>
<p>共现 : 共同出现</p>
</blockquote>
<h3>4.1 Word - Word</h3>
<p>&lt;img src=&quot;/images/nlp/word2vector-9.png&quot; width=&quot;620&quot; height=&quot;400&quot; align=&quot;middle&quot; /img&gt;</p>
<blockquote>
<p>左右窗 length 为 1， 得到的矩阵如上</p>
</blockquote>
<p>存在缺点</p>
<p>&lt;img src=&quot;/images/nlp/word2vector-10.png&quot; width=&quot;620&quot; height=&quot;400&quot; align=&quot;middle&quot; /img&gt;</p>
<blockquote>
<p>模型欠稳定，可以考虑下 LR 的各个参数等，变化太大，对模型求解有影响</p>
</blockquote>
<p><strong>用SVD对共现矩阵向量做降维</strong></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">la = np.linalg</span><br><span class="line"></span><br><span class="line">words = [<span class="string">"I"</span>, <span class="string">"like"</span>, <span class="string">"enjoy"</span>, <span class="string">"deep"</span>, <span class="string">"learning"</span>, <span class="string">"NLP"</span>, <span class="string">"flying"</span>, <span class="string">"."</span>]</span><br><span class="line"></span><br><span class="line">X = np.array(</span><br><span class="line">    [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">U, s, Vh = la.svd(X, full_matrices=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>SVD 降维存在的问题</strong></p>
<ul>
<li>
<p>计算量随语料库和词典增长膨胀太快，对X(n,n)维 的矩阵，计算量O(n^3)。而对大型的语料库， n~400k，语料库大小1~60B token</p>
</li>
<li>
<p>难以为词典中新加入的词分配词向量</p>
</li>
<li>
<p>与其他深度学习模型框架差异大</p>
</li>
</ul>
<h3>4.2 NNLM</h3>
<h3>4.3 Word2Vec: CBOW</h3>
<h3>4.4 Word2Vec: Skip-Gram</h3>
<h3>4.5 Word2Vec 缺点</h3>
<h2>5. 总结</h2>
<h3>5.1 离散表示</h3>
<ul>
<li>One-hot representation, Bag Of Words Unigram语言模型</li>
<li>N-gram词向量表示和语言模型</li>
<li>Co-currence矩阵的行(列)向量作为词向量</li>
</ul>
<h3>5.2 分布式连续表示</h3>
<ul>
<li>Co-currence矩阵的SVD降维的低维词向量表示</li>
<li>Word2Vec: Continuous Bag of Words Model</li>
<li>Word2Vec: Skip-Gram Model</li>
</ul>
<blockquote>
<p>gensim 用 python 训练 word2vec 最好用的库
它的功能不至于 word2vec</p>
</blockquote>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-tools/my-cooking" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/07/09/tools/my-cooking/"><strong>Scrambled Egg with Ham</strong></a>
      <small class=article-date-index>&nbsp; 2017-07-09</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/07/09/tools/my-cooking/" class="article-date">
  <time datetime="2017-07-09T12:54:16.000Z" itemprop="datePublished">2017-07-09</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/tools/">tools</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/07/09/tools/my-cooking/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>记录我学 Cooking 火腿炒蛋 的做法</p>
<p>&lt;!-- more --&gt;</p>
<ol>
<li>2个鸡蛋，打入小碗中，搅拌均匀</li>
<li>切一根火腿，切成片状</li>
<li>打开燃气阀门与起火，开小火便可</li>
<li>放入一些豆油，待油热一点</li>
<li>鸡蛋慢慢倒入油锅，鸡蛋成饼狀，期间可以颠勺</li>
<li>将火腿片，放入其中，进行一起炒，并可放入少量盐</li>
<li>炒得差不多后，关闭燃气阀门，并关闭起火开关</li>
</ol>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-python/language/py-language-basic-learning-III" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/06/05/python/language/py-language-basic-learning-III/"><strong>Python Basic Learning III</strong></a>
      <small class=article-date-index>&nbsp; 2017-06-05</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/06/05/python/language/py-language-basic-learning-III/" class="article-date">
  <time datetime="2017-06-05T03:00:21.000Z" itemprop="datePublished">2017-06-05</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/python/">python</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/06/05/python/language/py-language-basic-learning-III/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>廖雪峰的 Python 教程 - Functional Programming</p>
<p>&lt;!-- more --&gt;</p>
<h2>1. 函数式编程</h2>
<p>函数就是面向过程的程序设计的基本单元。</p>
<p>Functional Programming 其思想更接近数学计算。</p>
<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>
<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，<code>纯粹的函数式编程语言编写的函数没有变量</code>，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<h3>1.1 高阶函数</h3>
<p>Higher-order function</p>
<h2>2. 模块</h2>
<blockquote>
<p>Python内置的模块 和 来自第三方的模块。</p>
</blockquote>
<blockquote>
<p>每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</p>
</blockquote>
<h2>Reference</h2>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819196283586a37629844456ca7e5a7faa9b94ee8000" target="_blank" rel="noopener">廖雪峰的官方网站 liaoxuefeng</a></li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-python/language/py-language-8-class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/06/05/python/language/py-language-8-class/"><strong>Python Class</strong></a>
      <small class=article-date-index>&nbsp; 2017-06-05</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/06/05/python/language/py-language-8-class/" class="article-date">
  <time datetime="2017-06-05T02:00:21.000Z" itemprop="datePublished">2017-06-05</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/python/">python</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/06/05/python/language/py-language-8-class/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>OO 最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类</p>
<p>&lt;!-- more --&gt;</p>
<h2>Class def</h2>
<p>class 定义一个类,首字母大写，比如 Calculator. class可以先定义自己的属性，比如 name='Good Calculator'.</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span>       <span class="comment">#首字母要大写，冒号不能缺</span></span><br><span class="line">    </span><br><span class="line">    name=<span class="string">'Good Calculator'</span>  <span class="comment">#该行为class的属性</span></span><br><span class="line">    price=<span class="number">18</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line">        result = x + y</span><br><span class="line">        print(result)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        result=x-y</span><br><span class="line">        print(result)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">times</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        print(x*y)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        print(x/y)</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cal=Calculator()</span><br><span class="line"></span><br><span class="line">print(cal.name)</span><br><span class="line">print(cal.price)</span><br></pre></td></tr></table></figure></p>
<pre><code>Good Calculator
18
</code></pre>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cal.add(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">cal.minus(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">cal.times(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">cal.divide(<span class="number">10</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure></p>
<pre><code>Good Calculator
30
-10
200
0.5
</code></pre>
<h2>Class init</h2>
<p>运行 <code>c=Calculator('bad calculator',18,17,16,15)</code>, 然后调出每个初始值的值</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line">    name=<span class="string">'good calculator'</span></span><br><span class="line">    price=<span class="number">18</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,price,height,width,weight)</span>:</span>   <span class="comment"># 注意，这里的下划线是双下划线</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.price=price</span><br><span class="line">        self.h=height</span><br><span class="line">        self.wi=width</span><br><span class="line">        self.we=weight</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=Calculator(<span class="string">'bad calculator'</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">15</span>)</span><br><span class="line">print(c.name)</span><br><span class="line">print(c.price)</span><br><span class="line">print(c.h)</span><br><span class="line">print(c.wi)</span><br><span class="line">print(c.we)</span><br></pre></td></tr></table></figure></p>
<pre><code>bad calculator
18
17
16
15
</code></pre>
<h3>设置class属性默认值</h3>
<p>如何设置属性的默认值, 直接在def里输入即可，如下:</p>
<p><code>def __init__(self,name,price,height=10,width=14,weight=16):</code></p>
<p>查看运行结果， 三个有默认值的属性，可以直接输出默认值.</p>
<p>这些默认值可以在code中更改, 比如<code>c.wi=17</code>再输出<code>c.wi</code>就会把<code>wi</code>属性值更改为<code>17</code>.</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line">    name=<span class="string">'good calculator'</span></span><br><span class="line">    price=<span class="number">18</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,price,hight=<span class="number">10</span>,width=<span class="number">14</span>,weight=<span class="number">16</span>)</span>:</span> <span class="comment">#后面三个属性设置默认值,查看运行</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.price=price</span><br><span class="line">        self.h=hight</span><br><span class="line">        self.wi=width</span><br><span class="line">        self.we=weight</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=Calculator(<span class="string">'bad calculator'</span>,<span class="number">18</span>)</span><br><span class="line">print(c.h)</span><br><span class="line">print(<span class="string">"wi : "</span> + str(c.wi))</span><br><span class="line">c.wi = <span class="number">17</span></span><br><span class="line">print(<span class="string">"wi : "</span> + str(c.wi))</span><br><span class="line">print(c.we)</span><br></pre></td></tr></table></figure></p>
<pre><code>10
wi : 14
wi : 17
16
</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="https://docs.python.org/" target="_blank" rel="noopener">docs.python.org</a></li>
<li><a href="https://morvanzhou.github.io/" target="_blank" rel="noopener">python morvanzhou</a></li>
<li><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">python liaoxuefeng</a></li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-python/language/py-language-6-read-file" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/06/04/python/language/py-language-6-read-file/"><strong>Python Read File</strong></a>
      <small class=article-date-index>&nbsp; 2017-06-04</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/06/04/python/language/py-language-6-read-file/" class="article-date">
  <time datetime="2017-06-04T02:00:21.000Z" itemprop="datePublished">2017-06-04</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/python/">python</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/06/04/python/language/py-language-6-read-file/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>open()、append、file.read()、file.readline()、file.readlines()、file.close()、with open .. as f</p>
<p>&lt;!-- more --&gt;</p>
<p>读写文件前，必须了解，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个<code>文件对象</code>（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）</p>
<h2>1. open</h2>
<p>使用 <code>open</code> 能够打开一个文件, <code>open</code> 的第一个参数为文件名和路径 ‘my file.txt’, 第二个参数为将要以什么方式打开它, 比如 <code>w</code> 为可写方式. 如果计算机没有找到 ‘my file.txt’ 这个文件, <code>w</code> 方式能够创建一个新的文件, 并命名为 <code>my file.txt</code></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">'This is my first test.'</span></span><br><span class="line"></span><br><span class="line">my_file=open(<span class="string">'my file.txt'</span>,<span class="string">'w'</span>)   <span class="comment">#用法: open('文件名','形式'), 其中形式有'w':write;'r':read.</span></span><br><span class="line">my_file.write(text)               <span class="comment">#该语句会写入先前定义好的 text</span></span><br><span class="line">my_file.close()                   <span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure></p>
<h2>2. append</h2>
<p>我们先保存一个已经有3行文字的 “my file.txt” 文件, 文件的内容如下:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is my first test. </span><br><span class="line">This is the second line.</span><br><span class="line">This the third</span><br></pre></td></tr></table></figure></p>
<p>使用添加文字的方式给这个文件添加一行 “This is appended file.”, 并将这行文字储存在 append_file 里，注意\n的适用性:</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">append_text=<span class="string">'\nThis is appended file.'</span>  <span class="comment"># 为这行文字提前空行 "\n"</span></span><br><span class="line">my_file=open(<span class="string">'my file.txt'</span>,<span class="string">'a'</span>)   <span class="comment"># 'a'=append 以增加内容的形式打开</span></span><br><span class="line">my_file.write(append_text)</span><br><span class="line">my_file.close()</span><br></pre></td></tr></table></figure></p>
<pre><code>	This is my first test.
	This is the second line.
	This the third line.
	This is appended file.
</code></pre>
<h2>3. file.read()</h2>
<p>调用 <code>read()</code> 会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取<code>size</code>个字节的内容。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file= open(<span class="string">'my file.txt'</span>,<span class="string">'r'</span>) </span><br><span class="line">content=file.read()  </span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure></p>
<pre><code>	This is my first test.
	This is the second line.
	This the third line.
	This is appended file.    
</code></pre>
<h2>4. file.readline()</h2>
<p>如果想在文本中一行行的读取文本, 可以使用 <code>file.readline()</code>, <code>file.readline()</code> 读取的内容和你使用的次数有关, 使用第二次的时候, 读取到的是文本的第二行, 并可以以此类推:</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file= open(<span class="string">'my file.txt'</span>,<span class="string">'r'</span>) </span><br><span class="line">content=file.readline()  <span class="comment"># 读取第一行</span></span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure></p>
<pre><code>This is my first test.
</code></pre>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">second_read_time=file.readline()  <span class="comment"># 读取第二行</span></span><br><span class="line">print(second_read_time)</span><br></pre></td></tr></table></figure></p>
<pre><code>This is the second line.
</code></pre>
<h2>5. file.readlines()</h2>
<p>如果想要读取所有行, 并可以使用像 <code>for</code> 一样的迭代器迭代这些行结果, 我们可以使用 <code>file.readlines()</code>, 将每一行的结果存储在 <code>list</code> 中, 方便以后迭代.</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file= open(<span class="string">'my file.txt'</span>,<span class="string">'r'</span>) </span><br><span class="line">content=file.readlines() <span class="comment"># python_list 形式</span></span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure></p>
<pre><code>['This is my first test.\n', 'This is the second line.\n', 'This the third line.\n', 'This is appended file.']
</code></pre>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 之后如果使用 for 来迭代输出:</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> content:</span><br><span class="line">    print(item)</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    This <span class="keyword">is</span> my first test.</span><br><span class="line"></span><br><span class="line">    This <span class="keyword">is</span> the second line.</span><br><span class="line"></span><br><span class="line">    This the third line.</span><br><span class="line"></span><br><span class="line">    This <span class="keyword">is</span> appended file.</span><br><span class="line"></span><br><span class="line"><span class="comment">## 6. file.close()</span></span><br><span class="line"></span><br><span class="line">由于文件读写时都有可能产生`IOError`，一旦出错，后面的`f.close()`就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用`<span class="keyword">try</span> ... <span class="keyword">finally</span>`来实现：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">print</span> f.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>每次都这么写实在太繁琐，所以，Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p>
</blockquote>
<h2>7. with open .. as f</h2>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">print</span> f.read()</span><br></pre></td></tr></table></figure></p>
<p>这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>
<h2>Reference</h2>
<ul>
<li><a href="https://docs.python.org/" target="_blank" rel="noopener">docs.python.org</a></li>
<li><a href="https://morvanzhou.github.io/tutorials/python-basic/basic/08-2-read-file2/" target="_blank" rel="noopener">python morvanzhou</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820066616a77f826d876b46b9ac34cb5f34374f7a000" target="_blank" rel="noopener">python liaoxuefeng</a></li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-python/language/py-language-10-advanced" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/06/03/python/language/py-language-10-advanced/"><strong>Python Slice、Iteration、List generation、Generator</strong></a>
      <small class=article-date-index>&nbsp; 2017-06-03</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/06/03/python/language/py-language-10-advanced/" class="article-date">
  <time datetime="2017-06-03T01:00:21.000Z" itemprop="datePublished">2017-06-03</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/python/">python</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/06/03/python/language/py-language-10-advanced/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>Slice、Iteration、List generation、Generator</p>
<p>&lt;!-- more --&gt;</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L = []</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">99</span>:</span><br><span class="line">    L.append(n)</span><br><span class="line">    n = n + <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2>1. Slice</h2>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:]</span><br><span class="line">[<span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = range(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)[:<span class="number">3</span>]</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>字符串<code>'xxx'</code>或Unicode字符串<code>u'xxx'</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFG'</span>[:<span class="number">3</span>]</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFG'</span>[::<span class="number">2</span>]</span><br><span class="line"><span class="string">'ACEG'</span></span><br></pre></td></tr></table></figure></p>
<h2>2. Iteration</h2>
<p>只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;list.length; i++) &#123;</span><br><span class="line">    n = list[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    <span class="keyword">print</span> key</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'ABC'</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> ch</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure></p>
<p>如何判断一个对象是可迭代对象呢？方法是通过<code>collections模块</code>的<code>Iterable</code>类型判断：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i, value</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></table></figure></p>
<p><code>for</code>循环里，同时引用了两个变量，在Python里是很常见</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> x, y</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<h2>3. List Generation</h2>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p>
<p>还可以使用两层循环，可以生成全排列：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></table></figure></p>
<p>运用列表生成式，可以写出非常简洁的代码。</p>
<p>例如，列出当前目录下的所有文件和目录名</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>)] <span class="comment"># os.listdir可以列出文件和目录</span></span><br><span class="line">[<span class="string">'.emacs.d'</span>, <span class="string">'.ssh'</span>, <span class="string">'.Trash'</span>, <span class="string">'Adlm'</span>, <span class="string">'Applications'</span>, <span class="string">'Desktop'</span>, <span class="string">'Documents'</span>, <span class="string">'Downloads'</span>, <span class="string">'Library'</span>, <span class="string">'Movies'</span>, <span class="string">'Music'</span>, <span class="string">'Pictures'</span>, <span class="string">'Public'</span>, <span class="string">'VirtualBox VMs'</span>, <span class="string">'Workspace'</span>, <span class="string">'XCode'</span>]</span><br></pre></td></tr></table></figure></p>
<p>for循环其实可以同时使用两个甚至多个变量，比如<code>dict</code>的<code>iteritems()</code>可以同时迭代key和value：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.iteritems():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> k, <span class="string">'='</span>, v</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">y = B</span><br><span class="line">x = A</span><br><span class="line">z = C</span><br></pre></td></tr></table></figure></p>
<p>列表生成式也可以使用两个变量来生成list：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.iteritems()]</span><br><span class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</span><br></pre></td></tr></table></figure></p>
<p>最后把一个list中所有的字符串变成小写：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'ibm'</span>, <span class="string">'apple'</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong></p>
<p>运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。</p>
<h2>4. Generator</h2>
<p>如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（<code>Generator</code>）</p>
<p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x104feab40</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>generator 是一个可迭代的对象</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> n</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure></p>
<p>斐波拉契数列</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">print</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><code>fib</code>函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</p>
<p>把<code>fib</code>函数变成<code>generator</code>，只需要把 <code>print b</code> 改为 <code>yield b</code> 就可以了</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果一个函数定义中包含 <code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator</p>
</blockquote>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">6</span>)</span><br><span class="line">&lt;generator object fib at <span class="number">0x104feaaa0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成<code>generator</code>的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code> 语句处继续执行。</p>
</blockquote>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">odd</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'step 1'</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'step 2'</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'step 3'</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = odd()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o.next()</span><br><span class="line">step <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o.next()</span><br><span class="line">step <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o.next()</span><br><span class="line">step <span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o.next()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong></p>
<p>generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。</p>
<p>要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束<code>for</code>循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，<code>for</code>循环随之结束。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868196169906eb9ca5864384546bf3405ae6a172b3e000" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-python/language/py-language-5-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/06/03/python/language/py-language-5-function/"><strong>Python def函数、函数参数、函数默认参数</strong></a>
      <small class=article-date-index>&nbsp; 2017-06-03</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/06/03/python/language/py-language-5-function/" class="article-date">
  <time datetime="2017-06-02T23:00:21.000Z" itemprop="datePublished">2017-06-03</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/python/">python</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/06/03/python/language/py-language-5-function/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>定义函数、内置函数、函数参数、函数默认参数</p>
<p>&lt;!-- more --&gt;</p>
<h2>1. 内置函数</h2>
<p>内置函数</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-12.34</span>)</span><br><span class="line"><span class="number">12.34</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://docs.python.org/2/library/functions.html#abs" target="_blank" rel="noopener">abs api</a></p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>数据类型转换</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'123'</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">12.34</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="string">'12.34'</span>)</span><br><span class="line"><span class="number">12.34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">1.23</span>)</span><br><span class="line"><span class="string">'1.23'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode(<span class="number">100</span>)</span><br><span class="line"><span class="string">u'100'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">''</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = abs <span class="comment"># 变量a指向abs函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2>2. def函数</h2>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>return None</code> 可以简写为 <code>return</code>。</p>
</blockquote>
<h3>2.1 空函数</h3>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h3>2.2 函数参数类型检查</h3>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure></p>
<h3>2.3 返回多个值 (是一个tuple)</h3>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> x, y</span><br><span class="line"><span class="number">151.961524227</span> <span class="number">70.0</span></span><br></pre></td></tr></table></figure></p>
<h2>3. 函数参数</h2>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>一是必选参数在前，默认参数在后，否则Python的解释器会报错</p>
<p>二是如何设置默认参数。</p>
<p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
<p>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p>
</blockquote>
<blockquote>
<p>定义默认参数要牢记一点：<code>默认参数必须指向不变对象！</code></p>
</blockquote>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
</blockquote>
<p><strong>可变参数</strong></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc((<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>))</span><br><span class="line"><span class="number">84</span></span><br></pre></td></tr></table></figure></p>
<p>如果利用可变参数，调用函数的方式可以简化成这样：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p>
<p>定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>这种写法相当有用，而且很常见，见如下 :</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure></p>
<p><strong>关键字参数</strong></p>
<p><code>可变参数</code>允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。</p>
<p><code>关键字参数</code>允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<p>请看示例：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw</span><br></pre></td></tr></table></figure></p>
<p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数; 也可以传入任意个数的关键字参数;</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **kw)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>参数组合</strong></p>
<p>在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw</span><br></pre></td></tr></table></figure></p>
<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>神奇的是通过一个tuple和dict，你也可以调用该函数：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p>
<p><strong>小结</strong></p>
<p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p>默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>
<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p>可变参数既可直接传入：<code>func(1, 2, 3)</code>，又可先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p>
<p>关键字参数既可直接传入：<code>func(a=1, b=2)</code>，又可先组装dict，再通过<code>**kw</code>传入：<code>func(**{'a': 1, 'b': 2})</code>。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<h3>递归函数</h3>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>
</blockquote>
<blockquote>
<p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p>
</blockquote>
<h2>Reference article</h2>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868196169906eb9ca5864384546bf3405ae6a172b3e000" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-python/language/py-language-4-collection-type" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/05/31/python/language/py-language-4-collection-type/"><strong>Python 集合 List、Tuple、Dict、 Set</strong></a>
      <small class=article-date-index>&nbsp; 2017-05-31</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/05/31/python/language/py-language-4-collection-type/" class="article-date">
  <time datetime="2017-05-31T08:00:21.000Z" itemprop="datePublished">2017-05-31</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/python/">python</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/05/31/python/language/py-language-4-collection-type/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>Python 集合 List、Tuple、Dict、 Set</p>
<p>&lt;!-- more --&gt;</p>
<h2>List</h2>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></p>
<h3>append</h3>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-1</span>]</span><br><span class="line"><span class="string">'Tracy'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></p>
<h3>insert</h3>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></table></figure></p>
<h3>pop</h3>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</span><br><span class="line"><span class="string">'Adam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>要删除list末尾的元素，用<code>pop()</code>方法</p>
</blockquote>
<h3>pop(i)</h3>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">'Jack'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置：</p>
</blockquote>
<h3>list 元素类型不同</h3>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Apple'</span>, <span class="number">123</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>list 里面的元素的数据类型也可以不同</p>
</blockquote>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = [<span class="string">'asp'</span>, <span class="string">'php'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, p, <span class="string">'scheme'</span>]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>list元素也可以是另一个list</p>
</blockquote>
<h2>Tuple</h2>
<p><code>tuple</code>一旦初始化就不能修改,元素指向不改变</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = (<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>)</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果要定义一个空的tuple，可以写成<code>()</code></p>
<blockquote>
<p>tuple 的陷阱</p>
</blockquote>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>正确的方式如下 :</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure></p>
<p>最后来看一个“可变的”tuple：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])</span><br><span class="line">&gt;&gt;&gt; t[2][0] = &apos;X&apos;</span><br><span class="line">&gt;&gt;&gt; t[2][1] = &apos;Y&apos;</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])</span><br></pre></td></tr></table></figure></p>
<p>其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list</p>
<h2>Dict</h2>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</span><br><span class="line"><span class="number">95</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>] = <span class="number">67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>]</span><br><span class="line"><span class="number">67</span></span><br></pre></td></tr></table></figure></p>
<h3>判断 key 是否存在</h3>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：返回None的时候Python的交互式命令行不显示结果。</p>
</blockquote>
<h3>删除 key，pop(key)</h3>
<p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>dict</th>
<th>list</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找和插入的速度极快，不会随着key的增加而增加</td>
<td>查找和插入的时间随着元素的增加而增加</td>
</tr>
<tr>
<td>需要占用大量的内存，内存浪费多</td>
<td>占用空间小，浪费内存很少</td>
</tr>
</tbody>
</table>
<p><strong>所以，dict是用空间来换取时间的一种方法。</strong></p>
<blockquote>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。</p>
<p>是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：</p>
</blockquote>
<h2>Set</h2>
<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<h3>set init</h3>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>set([1, 2, 3])</code>只是告诉你这个set内部有1，2，3这3个元素，显示的[]不表示这是一个list。</p>
</blockquote>
<h3>add、remove</h3>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></p>
<h3>set &amp; and |</h3>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">set([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>set和dict的唯一区别仅在于没有存储对应的value，set的原理和dict一样.</p>
</blockquote>
<h3>difference、intersection</h3>
<p>我们还能进行一些筛选操作, 比如对比另一个东西, 看看原来的 set 里有没有和他不同的 (difference). 或者对比另一个东西, 看看 set 里有没有相同的 (intersection).</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">print(unique_char)</span><br><span class="line"><span class="comment"># &#123;'b', 'c', 'a'&#125;</span></span><br><span class="line"></span><br><span class="line">unique_char = <span class="keyword">set</span>(char_list)</span><br><span class="line">print(unique_char.difference(&#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>&#125;))</span><br><span class="line"><span class="comment"># &#123;'b', 'd', 'c'&#125;</span></span><br><span class="line"></span><br><span class="line">print(unique_char.intersection(&#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>&#125;))</span><br><span class="line"><span class="comment"># &#123;'a'&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2>议不可变对象</h2>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="string">'Abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'abc'</span></span><br></pre></td></tr></table></figure></p>
<p>小结 :</p>
<p>使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。</p>
<p><code>tuple</code> 虽然是不变对象，但试试把 <code>(1, 2, 3)</code> 和 <code>(1, [2, 3])</code> 放入dict或set中，并解释结果。</p>
<h2>Reference article</h2>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819196283586a37629844456ca7e5a7faa9b94ee8000" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-python/language/py-language-3-str-&amp;-character-encoding" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/05/31/python/language/py-language-3-str-&-character-encoding/"><strong>Python 字符编码 &amp; 字符串</strong></a>
      <small class=article-date-index>&nbsp; 2017-05-31</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/05/31/python/language/py-language-3-str-&-character-encoding/" class="article-date">
  <time datetime="2017-05-31T05:05:21.000Z" itemprop="datePublished">2017-05-31</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/python/">python</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/05/31/python/language/py-language-3-str-&-character-encoding/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>Python 字符编码 大概原理 与 字符串简单操作</p>
<p>&lt;!--more--&gt;</p>
<h2>字符编码</h2>
<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p>
<p>由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p>
<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>
<p><img src="/images/python/language-str-encoding.png" alt=""></p>
<p>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>字母<code>A</code>用ASCII编码是十进制的<code>65</code>，二进制的01000001；</p>
<p>字符<code>0</code>用ASCII编码是十进制的<code>48</code>，二进制的00110000，注意字符'0'和整数0是不同的；</p>
<p>你可以猜测，如果把ASCII编码的<code>A</code>用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p>
<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p>
<blockquote>
<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>
</blockquote>
<h2>字符串</h2>
<p>因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串<code>'ABC'</code>在Python内部都是ASCII编码的。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">65</span>)</span><br><span class="line"><span class="string">'A'</span></span><br></pre></td></tr></table></figure></p>
<p>Python在后来添加了对Unicode的支持，以Unicode表示的字符串用<code>u'...'</code>表示，比如：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">u'中文'</span></span><br><span class="line">中文</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中'</span></span><br><span class="line"><span class="string">u'\u4e2d'</span></span><br></pre></td></tr></table></figure></p>
<p>写<code>u'中'</code>和<code>u'\u4e2d'</code>是一样的，<code>\u</code>后面是十六进制的Unicode码。因此，<code>u'A'</code>和<code>u'\u0041'</code>也一样的。</p>
<p>两种字符串如何相互转换？字符串<code>'xxx'</code>虽然是ASCII编码，但也可以看成是UTF-8编码，而<code>u'xxx'</code>则只能是Unicode编码。</p>
<p>把<code>u'xxx'</code>转换为UTF-8编码的<code>'xxx'</code>用<code>encode('utf-8')</code>方法：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'ABC'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure></p>
<p>英文字符转换后表示的UTF-8的值和Unicode值相等（但占用的存储空间不同），而中文字符转换后1个Unicode字符将变为3个UTF-8字符，你看到的<code>\xe4</code>就是其中一个字节，因为它的值是<code>228</code>，没有对应的字母可以显示，所以以十六进制显示字节的数值。<code>len()</code>函数可以返回字符串的长度：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">u'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">u'中文'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>反过来，把UTF-8编码表示的字符串<code>'xxx'</code>转换为Unicode字符串<code>u'xxx'</code>用<code>decode('utf-8')</code>方法：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;abc&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">u&apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">u&apos;\u4e2d\u6587&apos;</span><br><span class="line">&gt;&gt;&gt; print &apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">中文</span><br></pre></td></tr></table></figure></p>
<h3>格式化</h3>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s'</span> % <span class="string">'world'</span></span><br><span class="line"><span class="string">'Hello, world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="string">'Hi, Michael, you have $1000000.'</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%2d-%02d'</span> % (<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="string">' 3-01'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%.2f'</span> % <span class="number">3.1415926</span></span><br><span class="line"><span class="string">'3.14'</span></span><br></pre></td></tr></table></figure></p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819196283586a37629844456ca7e5a7faa9b94ee8000" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-python/language/py-language-2-Output-Variable-dataType-If-While:For-PyHead" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/05/31/python/language/py-language-2-Output-Variable-dataType-If-While:For-PyHead/"><strong>Python Output、Variable、dataType、If、While/For、Py Head</strong></a>
      <small class=article-date-index>&nbsp; 2017-05-31</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/05/31/python/language/py-language-2-Output-Variable-dataType-If-While:For-PyHead/" class="article-date">
  <time datetime="2017-05-31T03:00:21.000Z" itemprop="datePublished">2017-05-31</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/python/">python</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/05/31/python/language/py-language-2-Output-Variable-dataType-If-While:For-PyHead/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>Python 的 print 语句、Variable 变量定义、 数据类型、条件与循环</p>
<p>&lt;!-- more --&gt;</p>
<h2>Output</h2>
<p><code>print</code>语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'The quick brown fox'</span>, <span class="string">'jumps over'</span>, <span class="string">'the lazy dog'</span>)</span><br></pre></td></tr></table></figure></p>
<pre><code>The quick brown fox jumps over the lazy dog
</code></pre>
<blockquote>
<p><code>print</code>会依次打印每个字符串，遇到逗号“,”会输出一个空格</p>
</blockquote>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(int(<span class="string">'2'</span>)+<span class="number">3</span>) <span class="comment"># int 字符串会转为整数</span></span><br><span class="line">print(int(<span class="number">1.9</span>))  <span class="comment"># int会保留整数部分</span></span><br><span class="line">print(float(<span class="string">'1.2'</span>)+<span class="number">3</span>) <span class="comment">#float()是浮点型，可以把字符串转换成小数</span></span><br></pre></td></tr></table></figure></p>
<pre><code>5
1
4.2
</code></pre>
<h2>Input</h2>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = input()</span><br><span class="line">Blair</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Hello,'</span>, name)</span><br><span class="line">Hello, Blair</span><br></pre></td></tr></table></figure></p>
<h2>Variable</h2>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b,c=<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span></span><br><span class="line">print(a,b,c)</span><br></pre></td></tr></table></figure></p>
<pre><code>11 12 13
</code></pre>
<h3>global var</h3>
<p>那如何在外部也能调用一个在局部里修改了的全局变量呢. 首先我们在外部定义一个全局变量 <code>a=None</code>, 然后再 <code>fun()</code> 中声明 这个 <code>a</code> 是来自外部的 <code>a</code>. 声明方式就是 <code>global a</code>. 然后对这个外部的 <code>a</code> 修改后, 修改的效果会被施加到外部的 <code>a</code> 上. 所以我们将能看到运行完 <code>fun()</code>, <code>a</code> 的值从 <code>None</code> 变成了 <code>20</code>.</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">APPLY = <span class="number">100</span> <span class="comment"># 全局变量</span></span><br><span class="line">a = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a    <span class="comment"># 使用之前在全局里定义的 a</span></span><br><span class="line">    a = <span class="number">20</span>      <span class="comment"># 现在的 a 是全局变量了</span></span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(APPLE)    <span class="comment"># 100</span></span><br><span class="line">print(<span class="string">'a past:'</span>, a)  <span class="comment"># None</span></span><br><span class="line">fun()</span><br><span class="line">print(<span class="string">'a now:'</span>, a)   <span class="comment"># 20</span></span><br></pre></td></tr></table></figure></p>
<h2>dataType</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>data type</th>
<th>example value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>int</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>float</td>
<td>1.2</td>
</tr>
<tr>
<td>3</td>
<td>str</td>
<td>'hello' or &quot;hello&quot;</td>
</tr>
<tr>
<td>4</td>
<td>boolean</td>
<td>True/False</td>
</tr>
<tr>
<td>5</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>6</td>
<td>常量</td>
<td></td>
</tr>
</tbody>
</table>
<h2>if/else</h2>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure></p>
<pre><code>teenager
</code></pre>
<h3>if/while 遇 None</h3>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> v1:</span><br><span class="line">   print(<span class="string">'v1'</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果 if / while 后面接着的语句数据类型 None, 将与 False 处理方式相同</p>
</blockquote>
<h3>if/while 遇 空集合</h3>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = []</span><br><span class="line"><span class="keyword">if</span> A:</span><br><span class="line">    print(<span class="string">"A is empty !"</span>)</span><br><span class="line"></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> A:</span><br><span class="line">    print(<span class="string">"A is not empty !"</span>)</span><br></pre></td></tr></table></figure></p>
<pre><code>A is not empty !
</code></pre>
<blockquote>
<p>在 Python 中集合类型有 list、 tuple 、dict 和 set 等，如果该集合对象作为 if 或 while 判断语句, 则与 False 处理方式相同</p>
</blockquote>
<h2>While/For</h2>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = range(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> a:</span><br><span class="line">    print(a[<span class="number">-1</span>])</span><br><span class="line">    a = a[:len(a)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<pre><code>4
3
2
1
0
</code></pre>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure></p>
<pre><code>Michael
Bob
Tracy
</code></pre>
<h2>py 程序头部</h2>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure></p>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p>
<p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会乱码。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819196283586a37629844456ca7e5a7faa9b94ee8000" target="_blank" rel="noopener">morvanzhou python</a></li>
<li><a href="https://morvanzhou.github.io/tutorials/python-basic/" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <article id="post-English/english-Shuping-Yang-at-Maryyland" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <myh11 itemprop="name">
      <a class="article-title-index" href="/2017/05/28/English/english-Shuping-Yang-at-Maryyland/"><strong>Shuping Yang&#39;s University of Maryland speech</strong></a>
      <small class=article-date-index>&nbsp; 2017-05-28</small>
      <!--<a>
      <div = post.date  </div>
      </a>-->
      <br>
      <br> <!-- blair add -->
    </myh11>
  


      </header>
    
    <div class="article-meta">
      <!--<a href="/2017/05/28/English/english-Shuping-Yang-at-Maryyland/" class="article-date">
  <time datetime="2017-05-27T23:08:21.000Z" itemprop="datePublished">2017-05-28</time>
</a>-->
      <!--
  <div class="article-category-index">
    <a class="article-category-index-link" href="/categories/English/">English</a>
  </div>

-->
      <!--
      
        <div class="article-comment-link-wrap">
          <a href="http://iequa.com/2017/05/28/English/english-Shuping-Yang-at-Maryyland/#disqus_thread" class="article-comment-link">Comments</a>
        </div>
      
      -->
    </div>
	
    <div class="article-entry" itemprop="articleBody">
      
        <p>Shuping Yang Maryland Graduation Speech About Air and Free</p>
<p>&lt;!-- more --&gt;</p>
<p><div class="video-container"><iframe src="//www.youtube.com/embed/9bMX-ctieHI" frameborder="0" allowfullscreen></iframe></div></p>
<h2>Speech Full Text</h2>
<blockquote>
<p><strong>Good afternoon faculty, students, parents and friends.</strong></p>
</blockquote>
<blockquote>
<p>I am truly honored and grateful to speak at the commencement for the University of Maryland, Class of 2017.</p>
<p>People often ask me: Why did you come to the University of Maryland?
I always answer: Fresh air.</p>
<p>Five years ago, as I step off the plane from China, and left the terminal at Dallas Airport. I was ready to put on one of my five face masks, but when I took my first breath of American air. I put my mask away.</p>
<p>The air was so sweet and fresh, and utterly luxurious.</p>
<p>I was surprised by this. I grew up in a city in China, where I had to wear a face mask every time I went outside, otherwise, I might get sick.</p>
<p>However, the moment Iinhaled and exhaled outside the airport，I felt free.</p>
<p>No more fog on my glasses, no more difficult breathing, no more suppression.</p>
<p>Every breath was a delight. As I stand here today, I cannot help, but recall that feeling of freedom.</p>
</blockquote>
<p> </p>
<blockquote>
<p>At the University of Maryland, I will soon feel another kind of fresh air for which I will beforever grateful — the fresh air of free speech.</p>
<p>Before I came to the UnitedStates, I learned in history class about the Declaration of Independence, butthese words had no meaning to me— Life, Liberty and the Pursuit of happiness.</p>
<p>I was merely memorizing the words to get good grades.</p>
<p>These words sounded so strange, so abstract and foreign to me, until I came to University of Maryland.</p>
<p>I have learned the right to freely express oneself is sacred in American.</p>
<p>Each day in Maryland, I was encouraged to express my opinions on controversial issues.</p>
<p>I could challenge astatement made by my instructor. I could even rate my professors online.</p>
<p>But nothing prepared me forthe culture shock I experienced when I watched a university production of the play— Twilight: Los Angeles.</p>
<p>Twilight is a play by AnnaDeavere Smith about the 1992 Los Angeles Riots.</p>
<p>The riots followed acquittal of four Los Angeles police officers in the videotaped arrest and beating of Rodney King.</p>
<p>For six days, the city was in chaos as citizens took to the streets.</p>
<p>In Twilight, the student actors were openly talking about racism, sexism and politics.</p>
<p>I was shocked, I never thought such topic could be discussed openly.</p>
<p>The play was my first taste of political story telling, one that makes the audience think critically.</p>
<p>I have always had a burning desire to tell these kinds of stories, but I was convinced that only authorities on the narrative, only authorities could define the truth.</p>
<p>However, the opportunity toimmerse myself in the perse community at the University of Maryland exposed me to various, many different perspectives on truth.</p>
<p>I soon realized that here I have the opportunity to speak freely.</p>
<p>My voice matters.</p>
<p>Your voice matters.</p>
<p>Our voices matter.</p>
<p>Civil engagement is not at ask just for politicians. I have witnessed this when I saw my fellow student smarching in Washington DC, voting in the presidential election and raising money to support various causes.</p>
<p>I have seen that everyone has a right to participate and advocate for change.</p>
<p>I used to believe that one inpidual participation could not make a difference, but here we are, United Terps.</p>
<p>Together, we can push our society to be more just, open and peaceful.</p>
<p>Class of 2017, we are graduating from a university that embraces a liberal arts education that nurtures us to think critically, and also to care and feel for humanity.</p>
<p>We are equipped with the knowledge of various disciplines and we are ready to face  the challenges of our society.</p>
<p>Some of us may go to graduate school, some us may step into professions and some of us may begin ajourney of exploration.</p>
<p>But no matter what we do,remember, democracy and free speech should not be taken for granted.</p>
<p>Democracy and freedom are the fresh air that is worth fighting for.</p>
<p>Freedom is oxygen. Freedomis passion. Freedom is love.</p>
<p>And as a French philosopher Jean Paul Sartre once said: freedom is a choice, our future is dependent on the choices we make today and tomorrow.</p>
<p>We are all playwrights of the next chapters of our lives. Together, we write the human history.</p>
<p>My friends, enjoy the fresh air and never ever let it go.</p>
<p>Thank you.</p>
</blockquote>

      
    </div>
	
    <!--
	
    -->
    <!--
    
      <footer class="article-footer">
      </footer>
    
    -->
  </div>
  
</article>



    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/12/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/14/">Next &amp;raquo;</a>
      </nav>
    

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Blair Chan&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/52binge/hexo-theme-blairos" target="_blank" rel="noopener">blairos</a>
    </div>
  </div>
</footer>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML,http://myserver.com/MathJax/config/local/local.js">
</script>

    
<script type="text/javascript"> <!-- add by blair 0724 type=text/javascript -->
  var disqus_shortname = 'blairos-sn';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
